## 125.方法引用：基于函数式接口,能够智能推断类型，与stream结合紧密。形如sorted(Person::compare)前者是类名,后者是静态方法

> # Java方法引用 vs 传统Lambda：为什么应该拥抱双冒号语法？
>
> 在Java函数式编程中，方法引用（Method References）与Lambda表达式就像一对孪生兄弟。它们都基于函数式接口实现，但在实际开发中，方法引用正在以独特的优势改变我们的编码方式。本文通过对比分析，揭示这个语法糖背后的深层价值。
>
> 核心区别对比
>
> ### 1. 代码简洁性（以排序为例）
>
> **传统Lambda写法**
> ```java
> persons.stream()
>        .sorted((a, b) -> Person.compareByAge(a, b))
> ````
>
> **方法引用写法**
>
> ```java
> persons.stream()
>        .sorted(Person::compareByAge)
> ```
>
> > 💡 双冒号语法消除冗余参数传递，代码长度缩短40%。在链式调用中，这种简洁性会被多次放大。
>
> ### 2. 类型推断智能度
>
> ```java
> // 需要显式声明参数类型
> BiFunction<Person, Person, Integer> comparator = 
>     (Person a, Person b) -> a.compareByAge(b);
> 
> // 编译器自动推断类型
> BiFunction<Person, Person, Integer> comparator = Person::compareByAge;
> ```
>
> > 🧠 编译器通过`BiFunction`的函数式接口定义，反向推导出方法引用参数类型。这种双向类型推断是Lambda做不到的。
>
> ### 3. 与Stream API的契合度
>
> ```java
> // 传统方式
> list.stream()
>     .map(s -> s.toUpperCase())
>     .filter(s -> s.startsWith("A"))
>     .forEach(s -> System.out.println(s));
> 
> // 方法引用方式
> list.stream()
>     .map(String::toUpperCase)
>     .filter(s -> s.startsWith("A"))
>     .forEach(System.out::println);
> ```
>
> > ⚡ 方法引用与Stream形成「语义化管道」，每个操作都像自然语言描述业务逻辑。
>
> ***
>
> ## 方法引用的四大优势
>
> ### 1. 类型安全盾牌
>
> ```java
> // 编译时立即发现类型错误
> Comparator<Person> wrongComparator = Person::compareByName; // 如果方法不存在则报错
> 
> // Lambda可能在运行时才暴露问题
> Comparator<Person> risky = (a,b) -> a.nonExistMethod(); // 延迟报错
> ```
>
> ### 2. 对象耦合解药
>
> ```java
> // 静态方法引用：Person::compareBySalary
> // 实例方法引用：person::getName
> // 构造器引用：Employee::new
> ```
>
> 每种引用类型都明确指定方法来源，避免隐式耦合。
>
> ### 3. 可维护性倍增器
>
> ```java
> // 看到Device::checkStatus 立刻明白校验逻辑
> devices.stream().filter(Device::checkStatus)
> 
> // Lambda需要深入查看实现细节
> devices.stream().filter(d -> d.getState() == State.ON && !d.isError())
> ```
>
> > 🔍 方法引用将业务语义提升到方法名级别，减少代码阅读时的认知负担。
>
> ### 4. 性能优化空间
>
> 虽然HotSpot会对二者做同样优化，但方法引用更利于：
>
> *   提前编译验证
> *   IDE静态分析
> *   字节码优化
>
> ***
>
> ## 最佳实践场景
>
> 1.  **替换简单Lambda**：当Lambda仅调用已有方法时
> 2.  **构造器代理**：`Stream.map(Employee::new)`
> 3.  **多级对象操作**：`user.getAddress()::getPostcode`
> 4.  **组合式编程**：`Comparator.comparing(Person::getBirthday)`
>
> ***
>
> ## 何时坚持用Lambda？
>
> *   需要自定义逻辑时：`(x, y) -> x*2 + y`
> *   多行代码块处理时
> *   需要修改外部变量时
>
> 
>
> > 选择依据：代码是否纯粹转发方法调用
>
> ***
>
> ## 进阶技巧
>
> **类型推断的特殊情况**
>
> ```java
> // 相同方法名时的显式类型指定
> Stream.<Person>of().sorted(Person::compareByAge)
> ```
>
> **与Optional的配合**
>
> ```java
> Optional.ofNullable(user)
>         .map(User::getProfile)
>         .map(Profile::getAvatarUrl)
>         .ifPresent(System.out::println);
> ```
>
> ***
>
> ## 总结
>
> 方法引用不是简单的语法糖，而是：
>
> *   声明式编程思想的体现
> *   类型系统的延伸
> *   可维护性与可靠性的保障
>
> 当我们在`forEach(System.out::println)`和`sorted(Person::compareByAge)`中大量使用时，实际上是在用代码宣告：这个操作不是创新逻辑，而是对已有行为的精确复用。
>
> **最后建议**：在代码评审中加入「方法引用检查项」，把可替换的Lambda逐个升级，让代码散发出函数式编程的真正魅力！

## 126.SpringBoot接口的QPS与响应时间监控方法：actuator+prometheus+grafana



---

> # 用Docker搭建SpringBoot监控系统：QPS与响应时间可视化实战
>
> 在微服务架构中，接口的QPS（每秒查询率）和响应时间是衡量服务健康度的重要指标。本文将手把手教你使用Docker搭建完整的监控系统，并通过代码示例展示具体实现。
>
> ## 技术栈全景图
> ```mermaid
> graph LR
> A[SpringBoot应用] --> B(Actuator端点)
> B --> C(Prometheus)
> C --> D{Grafana}
> ```
>
> ---
>
> ## 一、SpringBoot应用配置
>
> ### 1. 添加依赖
> ```xml
> <!-- pom.xml -->
> <dependency>
>     <groupId>org.springframework.boot</groupId>
>     <artifactId>spring-boot-starter-actuator</artifactId>
> </dependency>
> <dependency>
>     <groupId>io.micrometer</groupId>
>     <artifactId>micrometer-registry-prometheus</artifactId>
> </dependency>
> ```
>
> ### 2. 配置Actuator
> ```yaml
> # application.yml
> management:
>   endpoints:
>     web:
>       exposure:
>         include: prometheus,health,metrics
>   metrics:
>     tags:
>       application: ${spring.application.name}
> ```
>
> ### 3. 验证端点
> ```bash
> curl http://localhost:8080/actuator/prometheus
> # 应看到类似指标输出
> # http_server_requests_seconds_count{...} 1234.0
> ```
>
> ---
>
> ## 二、Docker部署中间件
>
> ### 1. docker-compose编排
> ```yaml
> # monitoring-stack.yml
> version: '3'
> 
> services:
>   prometheus:
>     image: prom/prometheus
>     ports:
>       - "9090:9090"
>     volumes:
>       - ./prometheus.yml:/etc/prometheus/prometheus.yml
> 
>   grafana:
>     image: grafana/grafana
>     ports:
>       - "3000:3000"
>     volumes:
>       - grafana-storage:/var/lib/grafana
>     depends_on:
>       - prometheus
> 
> volumes:
>   grafana-storage:
> ```
>
> ### 2. Prometheus配置
> ```yaml
> # prometheus.yml
> scrape_configs:
>   - job_name: 'spring-app'
>     metrics_path: '/actuator/prometheus'
>     static_configs:
>       - targets: ['host.docker.internal:8080'] # 宿主机应用地址
> ```
>
> ---
>
> ## 三、Grafana可视化配置
>
> ### 1. 添加数据源
> 1. 访问 http://localhost:3000
> 2. 添加Prometheus数据源
> 3. URL填写 `http://prometheus:9090`
>
> ### 2. 导入Dashboard
> 使用官方模板ID `4701`，自动生成以下监控面板：
>
> | 监控项       | PromQL示例                                                   |
> | ------------ | ------------------------------------------------------------ |
> | 总QPS        | sum(rate(http_server_requests_seconds_count[1m]))            |
> | 平均响应时间 | rate(http_server_requests_seconds_sum[1m])/rate(http_server_requests_seconds_count[1m]) |
> | 按状态码统计 | sum by(status) (http_server_requests_seconds_count)          |
>
> ---
>
> ## 四、高级监控技巧
>
> ### 1. 自定义业务指标
> ```java
> @RestController
> public class OrderController {
> 
>     private final Counter orderCounter;
> 
>     public OrderController(MeterRegistry registry) {
>         orderCounter = registry.counter("order.create.count");
>     }
> 
>     @PostMapping("/orders")
>     public void createOrder() {
>         orderCounter.increment();
>         // 业务逻辑...
>     }
> }
> ```
>
> ### 2. 告警规则配置
> ```yaml
> # prometheus.yml
> rule_files:
>   - alerts.yml
> ```
>
> ```yaml
> # alerts.yml
> groups:
> - name: spring-alerts
>   rules:
>   - alert: HighErrorRate
>     expr: sum(rate(http_server_requests_seconds_count{status=~'5..'}[5m])) / sum(rate(http_server_requests_seconds_count[5m])) > 0.1
>     for: 10m
> ```
>
> ---
>
> ## 五、常见问题排查
>
> 1. **指标不显示？**
>    - 检查`/actuator/prometheus`端点是否可达
>    - 确认Prometheus targets状态为UP
>
> 2. **Docker网络不通？**
>    - 使用`host.docker.internal`（Mac/Win）
>    - Linux使用`--network=host`模式
>
> 3. **指标延迟？**
>    ```yaml
>    # Prometheus配置
>    scrape_interval: 15s
>    evaluation_interval: 15s
>    ```
>
> ---
>
> ## 总结
>
> 通过本文的配置，我们实现了：
> ✅ 实时QPS监控
> ✅ 响应时间分布可视化
> ✅ 异常状态码告警
> ✅ 自定义业务指标追踪
>
> 这套监控方案每天可处理百万级指标数据，内存消耗控制在500MB以内，是轻量级监控的优选方案。