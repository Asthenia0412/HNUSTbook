## 127.IO阻塞时CPU分析：(无DMA则PIO,效率低,有DMA则走DMA-上下文切换有开销-nodejs高效是因为单线程任务循环,(无上下文切换)+用户条事件调度/Tomcat用BIO,但限制池子大小+切换就绪线程+epoll也可以令BIO媲美AIO)

> ---
>
> ### **IO密集型应用：当线程遭遇IO阻塞时，CPU在忙什么？**
>
> 要理解IO密集型应用中的CPU占用问题，我们需要深入操作系统调度、硬件交互和线程模型的细节。本文将通过**三个核心问题**，结合硬件原理与代码级优化，为你揭示IO阻塞背后的真相。
>
> ---
>
> #### **1. 为什么DMA是IO密集应用的救星？**
>
> **传统PIO模式（无DMA）**：  
> 假设线程需要从磁盘读取1GB数据，在早期计算机中，CPU需要亲自参与每个字节的传输（Programmed I/O，PIO）。此时，CPU被完全占用，无法处理其他任务，效率极低。
>
> **DMA模式**：  
> 现代硬件通过DMA控制器解放了CPU。流程如下：  
> 1. 线程发起磁盘读取请求，操作系统将任务提交给DMA控制器。  
> 2. **线程进入休眠状态**（状态标记为`TASK_UNINTERRUPTIBLE`），CPU不再参与数据传输。  
> 3. DMA控制器直接管理磁盘与内存之间的数据传输，完成后通过**硬件中断**通知CPU。  
> 4. 线程被唤醒，继续执行后续代码。  
>
> **关键点**：  
> - **CPU零拷贝**：DMA绕过CPU直接操作内存，避免CPU陷入“搬运工”角色。  
> - **中断风暴问题**：高频小数据量IO（如网络包）可能导致频繁中断。此时，现代网卡支持**NAPI机制**（混合中断+轮询），在流量高峰时切换为轮询模式，减少中断次数。  
>
> **生动比喻**：  
> DMA就像一个专业的快递分拣机器人，CPU只需告诉它“把货物从A送到B”，然后去处理其他任务，无需亲自搬运每一个包裹。
>
> ---
>
> #### **2. 上下文切换：被忽视的性能刺客**
>
> **线程休眠与唤醒的成本**：  
> 当线程因IO阻塞休眠时，操作系统需要执行以下步骤：  
> 1. **保存上下文**：将CPU寄存器、程序计数器等状态保存到线程内核栈。  
> 2. **调度新线程**：从就绪队列选择下一个线程，加载其上下文。  
> 3. **缓存失效**：新线程可能冲刷CPU缓存（如TLB、L1/L2 Cache），导致后续指令执行变慢。  
>
> **量化开销**：  
> - 一次上下文切换耗时约**1~10微秒**（取决于CPU架构）。  
> - 若每秒发生10万次切换，CPU将浪费**100ms~1s**时间，相当于损失10%~100%的单核算力！  
>
> **Node.js为何高效？**  
> Node.js的秘诀在于**绕过线程模型**：  
> - **单线程事件循环**：所有IO操作通过`epoll`/`kqueue`异步通知，**无上下文切换**。  
> - **用户态任务调度**：通过`libuv`库在用户态管理任务队列，切换成本远低于内核线程。  
> - **对比实验**：用Apache（多线程）与Nginx（事件驱动）处理静态文件，在10k并发时，Nginx的CPU占用率可能仅为Apache的1/10。  
>
> **操作系统级优化**：  
> - **线程 vs 协程**：Linux的`io_uring`（内核协程）将部分调度逻辑移至用户态，减少模式切换。  
> - **Windows Overlapped IO**：通过IOCP（完成端口）实现零拷贝唤醒，线程池动态调整工作线程数量。  
>
> ---
>
> #### **3. 多线程阻塞IO为何可能高效？打破直觉的真相**
>
> **经典误解**：“多线程阻塞IO == 性能差”。实际上，**合理的线程池设计**可以使其媲美异步IO。  
>
> **案例：Java NIO与Tomcat线程池**  
> - Tomcat默认使用**阻塞IO模型**，但通过限制线程池大小（如200线程），避免线程爆炸。  
> - 当线程阻塞时，CPU自动切换其他就绪线程，**利用时间片重叠IO等待时间**。  
> - 配合内核的**IO多路复用**（如`epoll`），即使使用阻塞IO，实际阻塞发生在`epoll_wait`阶段，而非真实IO。  
>
> **性能关键点**：  
> - **线程池大小公式**：  
>   `线程数 = CPU核心数 * 目标CPU利用率 * (1 + 平均等待时间/平均计算时间)`  
>   对于IO密集型任务，若等待时间占90%，则线程数可设为`CPU核心数 * (1 + 0.9/0.1) = 10*CPU核心数`。  
> - **零拷贝优化**：`sendfile`系统调用允许数据从磁盘直接发送到网卡，无需经用户态。  
> - **内核旁路（Kernel Bypass）**：DPDK/SPDK等框架直接操作网卡/磁盘，彻底避免上下文切换。  
>
> **生动场景**：  
> 想象一个餐厅（CPU）有10名服务员（线程）。如果每个服务员在等菜（IO）时僵在原地，餐厅效率必然低下。但若服务员在等菜时去服务其他顾客（切换线程），整体吞吐量反而可能更高——这就是多线程阻塞IO的合理使用场景。
>
> ---
>
> #### **终极结论：没有银弹，只有权衡**  
>
> - **DMA是基础**：现代IO必须依赖DMA，否则CPU会被数据搬运淹没。  
> - **上下文切换是敌人**：无论用哪种模型（线程/事件驱动），核心目标都是减少切换次数。  
> - **异步 vs 多线程**：  
>   - 小规模高并发（如10k连接）→ 事件驱动（Node.js/Nginx）。  
>   - 大规模计算+IO混合（如数据库）→ 协程+线程池混合模型（Go/Java Loom）。  
>
> **最后，通过一张表总结各方案的CPU占用特点**：  
>
> | 模型               | 典型代表  | CPU占用特点              | 适用场景          |
> | ------------------ | --------- | ------------------------ | ----------------- |
> | 阻塞IO多线程       | Tomcat    | 高线程切换开销，但易编程 | 传统企业应用      |
> | 事件驱动单线程     | Node.js   | 几乎零切换，但受限于单核 | 高并发低计算      |
> | 协程（用户态线程） | Go/Erlang | 极低切换开销，利用多核   | 通用高并发        |
> | 内核旁路           | DPDK/SPDK | 零切换，独占CPU核        | 超高性能网络/存储 |
>
> 理解这些底层机制，你才能真正驾驭IO密集型应用的性能优化。
>
> 

## 128.预防SQL注入：前端表格name和后端sql查询的column不能相同,避免在使用${}表达字段时,被注入令where无效的语句,导致数据库泄露.牢记前端数据是不可信的！

> ## SQL注入预防：切记前端数据不可靠
>
> SQL注入（SQL Injection）是当应用程序允许用户输入未经验证的数据直接插入到数据库查询中时，攻击者可以利用这一点插入恶意SQL语句，从而获得数据库的机密信息或执行其他恶意操作。为了有效预防SQL注入，我们需要理解如何使用正确的参数化查询来避免漏洞。
>
> 在我们来详细分析一下问题之前，首先理解两种常见的数据库查询方式：`#{}（Mybatis）`和`${}`（Mybatis）。这两者的行为大不相同，直接影响到是否容易受到SQL注入攻击。
>
> ### 1. 参数化查询：`#{}` vs `${}`
>
> #### `#{}`：防止SQL注入的武器
>
> 在Mybatis框架中，`#{}`表示一个参数化的占位符。在执行SQL时，Mybatis会自动将传入的值作为参数处理，确保它们作为“值”而非SQL代码来执行。这种方式有效避免了SQL注入的风险，因为数据库引擎将处理它们时，不会将它们作为SQL语句的一部分执行，而是会将它们视作数据。
>
> 例如，下面的SQL语句使用了`#{value}`：
>
> ```xml
> <select name="query">
>     select * from t where ${name} like #{value}
> </select>
> ```
>
> 假设`value`传入的是用户输入的字符串，它会被Mybatis自动转义或处理为查询参数，而不是直接嵌入到SQL中，从而有效避免了恶意SQL注入的发生。
>
> #### `${}`：危险的模板字符串
>
> 相比之下，`${}`表示的是字符串的直接插入，Mybatis会把传入的参数直接替换到SQL中，**这可能导致SQL注入漏洞**。举个例子：
>
> ```xml
> <select name="query">
>     select * from t where ${name} like #{value}
> </select>
> ```
>
> 如果`name`是用户输入的，像`field=title`，那它会直接作为SQL的一部分被插入到查询中。这就给黑客提供了可乘之机，尤其当`field`参数由前端直接传入时，攻击者可以在`field`中注入恶意代码。
>
> ### 2. 黑客的攻击：如何利用SQL注入
>
> 假设攻击者发现了上述SQL的漏洞，可以利用`field`参数注入恶意SQL代码。攻击者可能这样构造请求：
>
> ```java
> /query?field=title like '% and author = '刘慈欣' or title&value=java
> ```
>
> 这样，SQL查询就会变成：
>
> ```sql
> select * from t where title like '%' and author = '刘慈欣' or title like '%java%'
> ```
>
> 这条SQL语句被执行后，查询不仅会根据`title`字段查找包含`java`的记录，还会因为`and author = '刘慈欣'`的条件被引入，绕过了原本应该只查找`title`的限制，返回了可能包含敏感信息的记录。这就是SQL注入的典型场景。
>
> ### 3. 解决方案：严格控制前后端传递的字段值
>
> 要避免SQL注入，首先要理解数据的来源和用途，尤其是前端传来的数据。攻击者可能通过前端表单或URL参数传递恶意数据，因此我们需要在后端对传入的所有参数进行严格检查与处理。
>
> 一种有效的解决方法是**前端的字段和后端的字段值不一致**。即使前端传递的字段是`title`，后端接收的字段可能设置为`name`，这样即便攻击者将恶意代码传递给`field`，后端不直接接受这个传值，而是根据自己的逻辑匹配实际的数据库字段，避免了直接拼接恶意SQL。
>
> 例如，假设前端传入：
>
> ```html
> <select name="field">
>     <option value="s1">Title</option>
>     <option value="s2">Description</option>
> </select>
> ```
>
> 而后端接收到的`field`和`value`可能会映射到不同的数据库字段名，如下所示：
>
> ```java
> @PostMapping("/query")
> public Response query(String field, String value){
>     Map<String, Object> params = new HashMap<>();
>     // 根据前端传入的field动态映射数据库字段
>     String mappedField = mapFieldToDatabaseColumn(field); // 比如 s1 -> title, s2 -> description
>     params.put("name", mappedField);  // 传递映射后的字段名
>     params.put("value", "%" + value + "%");
>     session.selectList("query", params);
> }
> ```
>
> 然后在Mybatis的SQL映射中，使用`#{}`来防止SQL注入：
>
> ```xml
> <select name="query">
>     select * from t where ${name} like #{value}
> </select>
> ```
>
> 通过这种方式，攻击者即使构造了类似`title like '% and author = '刘慈欣' or title&value=java`的恶意请求，后台也不会直接执行，因为SQL中的`name`被映射到了安全的数据库字段，不会直接执行不受信任的SQL逻辑。
>
> ### 4. 结论：从根源上避免SQL注入
>
> SQL注入的本质是对用户输入数据的处理不当导致的安全漏洞。通过参数化查询（`#{}`）和避免直接拼接SQL（`${}`），可以大大降低SQL注入的风险。同时，后端对前端数据的严格验证和控制，如字段映射和过滤，也能够有效防止潜在的攻击。
>
> 对于开发者来说，永远记住：**前端数据永远不可信**，即使是最简单的下拉框，也不能完全信任其传来的值。通过采取适当的安全措施，我们可以有效避免SQL注入，并保护系统免受攻击。

## 129.并发流程的线性一致性：

> 