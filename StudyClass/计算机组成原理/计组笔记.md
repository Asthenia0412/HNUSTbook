
## 3.1存储器概述
### A.按存取方式分：
- RAM
- ROM
- SAM（顺序-磁带）
- DAM（直接-磁盘存储器）
### B.断电后是否保存：
- 易失性：断电后存储信息消失，如RAM
- 非易失性：断电后存储信息依旧保存，如ROM、磁盘、磁带、光盘
### C.读出方式：
- 破坏性读出：DRAM
- 非破坏性读出：SRAM
### D.性能指标：
#### D.1储存单元：
- 存储字：一个二进制由若干位组成，这个二进制数作为整体存入或者取出，这个数就是存储字，存储字的长度取决于MDR。
- 存储单元：存储体的组成单位。存储单元的个数取决于MAR的次方。
- 一个存储单元可以存放一个字，也可以存放一个字节。
#### D.2编址和寻址：
- 地址：存储单元的编号，用于区别存储体中的若干存储单元。
- 编址：给每个房间编号
  - 字节编址：最小寻址单位是一个字节。
  - 字编址：最小寻址单元是一个字。
- 寻址：根据地址找到存储单元的过程。
#### D.3存储容量：
- 存储单元的个数 x 每个单元的比特数（如果是按字节编址则为存储单元个数x8，如果是按字编址则为存储单元个数x字中的比特数）。
#### D.4存取时间（很少用）：
- T_A：存储器接到读命令到信息被送到数据线上的时间。
- T_W：存储器接到写命令到信息被写入存储器的时间。
#### D.5存取周期（T_M）：
- T_M > T_A
- T_M > T_W
- 一个访问时间与一个恢复时间构成一个存取周期。
## 3.2主存：
### A.DRAM工作原理：

- 写入：MOS管接通+电容存入电荷。
- 读出：MOS管放开+电容电荷流失+信号放大器感知+计算机了解该位数据已读出。
- 问题：读出是破坏性的，因此需要再生。
### B.DRAM VS SRAM：
| 特征       | SRAM         | DRAM       |
| ---------- | ------------ | ---------- |
| 构成       | 双稳态触发器 | 电容       |
| 破坏性读出 | 否           | 是         |
| 再生       | 不需要       | 需要       |
| 易失性     | 是           | 是         |
| 送行列地址 | 同时送       | 行列分开送 |
| 地址复用   | 否           | 是         |
| 速度       | 快           | 慢         |
| 刷新       | 不需要       | 需要       |
| 集成度     | 低           | 高         |
| 功耗       | 高           | 低         |
| 价格       | 高           | 低         |
### C.半导体存储芯片：

![image-20241212190116335](./assets/image-20241212190116335.png)

![image-20241212190105872](./assets/image-20241212190105872-1734001266987-1.png)

![image-20241212190253813](./assets/image-20241212190253813.png)

- 基本结构：译码驱动电路 -> 存储矩阵 -> 读写电路
  - 译码驱动电路：与地址线连接，负责将地址信号转换为特定存储单元选择信号。
  - 存储矩阵：存储单元的集合。
  - 读写电路：与数据线连接，负责写入或读取数据。
  - 外部相联：
    - 片选线：单向，负责选定要访问的存储器芯片。
    - 读写控制线：单向，负责下达读写命令。
    - 数据线：双向，传递数据。
    - 地址线：单向，将地址传入译码器。
- 译码驱动方式（重要）：
        - 单译码法(线选法)：地址译码器仅有一个
          - 通过n个地址引脚定义一个大小为2^n的地址空间
          - 地址输入线的引脚n=4，经过地址译码器译码，有2^4一共16个状态，对应16个地址。则存储单元的地址为000B~111B
          - 译码后输出的线过多，因此只适合**容量小**的**静态存储器**
      - 双译码法(重合法)：
        - 建立笛卡尔坐标系，实数对(X,Y)唯一确定1个存储单元。X由行地址译码驱动，Y由列地址译码驱动。
        - 输入端为n根引脚，有n/2根行地址线，也就是有2^(n/2)行，有n/2根列地址线，也就是 2^(n/2)列。因此，输出端引脚只需要 2^(n/2)+1个。适合大容量的动态存储器
        - 行缓冲：
        - 位平面：

### D.DRAM的刷新：

#### D.1为什么DRAM要刷新？

因为DRAM的本质是一个MOS管+电容，电容会漏电，因此需要定期充电

#### D.2集中刷新

![image-20241212190534127](./assets/image-20241212190534127.png)

#### D.3分散刷新

![image-20241212190553640](./assets/image-20241212190553640.png)

#### D.4异步刷新

![image-20241212190606846](./assets/image-20241212190606846.png)

## 3.3主存容量扩展以及并行技术

### A.扩展技术

#### A.1位扩展：

![image-20241212194252562](./assets/image-20241212194252562.png)

我的需求是：256k x 8

但是我只有八块256k x 1的芯片，那么我会在横向上进行拼接

#### A.2字扩展：

如何理解字：存储体中存储单元的个数。

![image-20241212194553006](./assets/image-20241212194553006.png)

![image-20241212194659484](./assets/image-20241212194659484.png)

#### A.3字位扩展

![image-20241212194740076](./assets/image-20241212194740076.png)

![image-20241212194805777](./assets/image-20241212194805777.png)

### B.并行技术

#### B.1双端口

![image-20241212194843231](./assets/image-20241212194843231.png)

#### B.2单体多字存储器

![image-20241212194929735](./assets/image-20241212194929735.png)

#### B.3交叉访问存储器-模块访问

##### B.3.1高位多体交叉

![image-20241212195144916](./assets/image-20241212195144916.png)

##### B.3.2低位多体交叉(重要)

![image-20241212195228064](./assets/image-20241212195228064.png)

##### B.3.3轮流启动

![image-20241212195430414](./assets/image-20241212195430414.png)

##### B.3.4同时启动

![image-20241212195529048](./assets/image-20241212195529048.png)

### C.字位扩展技术与并行技术总结

![image-20241212195559713](./assets/image-20241212195559713.png)

## 3.4外部存储器

### A.磁盘存储

#### A.1组成

**盘片、盘面**

![image-20241212201151008](./assets/image-20241212201151008.png)

**盘面与扇区**

![image-20241212201211836](./assets/image-20241212201211836.png)

**磁头臂**

![image-20241212201631815](./assets/image-20241212201631815.png)

#### A.2存取时间

![image-20241212201646222](./assets/image-20241212201646222.png)

#### A.3地址结构

![image-20241212201803146](./assets/image-20241212201803146.png)

### B.固态硬盘

#### B.1基本结构与工作原理

![image-20241212201929823](./assets/image-20241212201929823.png)

#### B.2读写原理

![image-20241212202035071](./assets/image-20241212202035071.png)

#### B.3磨损均衡技术

原因是：不希望某一块闪存中的块被反复擦除(因为SSD写入需要擦除旧的内容)

![image-20241212202215611](./assets/image-20241212202215611.png)

### C.二者比较

![image-20241212202306823](./assets/image-20241212202306823.png)

## 3.5高速缓存处理器

### A.程序访问的局部性原理

![image-20241212205213141](./assets/image-20241212205213141.png)

![image-20241212205240919](./assets/image-20241212205240919.png)

### B.cache与主存块 

> Cache的一个块：对应存储体中的多个存储单元

![image-20241212205331638](./assets/image-20241212205331638.png)

### C.cache的有效位

> Cache的有效位：解决Cache和主存中的数据不一致问题
>
> 在每一个Cache块前都用有效位表示：
>
> 其中有效位为1表示：当前Cache的值和主存中是一致的
>
> 其中有效位为0表示：当前Cache中的值和主存的值是不一样的！

![image-20241212205508311](./assets/image-20241212205508311.png)

### D.cache的访问过程

![image-20241212205655655](./assets/image-20241212205655655.png)

### E.cache-主存层次的访问时间

> CPU在cache-主存层次的平均访问时间公式记忆：
>
> T=命中率x命中时间+缺失率x缺失时间
>
> 切记缺失时间是（T_m+T_c）

![image-20241212205811547](./assets/image-20241212205811547.png)

### F.映射方式

> 这一块的难点是：
>
> 1.你得记住不同映射标准下的地址划分标准，也就是给你一个二进制表达的数字串，你要能区分出哪几位是标记，那几位是行号or其他的特性
>
> 2.你这的地址划分是对主存地址的划分，是主存！是主存！是主存！！！！

#### F.1直接映射

> 直接映射：
>
> 任何一个主存块只能映射到**特定的Cache行**中
>
> 标记也叫Tag

![image-20241212210213771](./assets/image-20241212210213771.png)

#### F.2全相联

> 你好像发觉了：在全相联映射中，没有Cache行号的概念了！
>
> 你的猜想没错，全相联映射的主存块可以映射到任意的Cache行中，因此Cache行号失去了存在的价值

![image-20241212210403037](./assets/image-20241212210403037.png)

#### F.3组相连

> 组相联的结构和直接相联比较类似
>
> 但是有很大的一点差异：
>
> 组相联映射下的主存地址划分中：中间部分**并非**Cache**行号**，**而是**Cache**组号**。

![image-20241212210511996](./assets/image-20241212210511996.png)

#### F.4比较器个数

![image-20241212210720378](./assets/image-20241212210720378.png)

#### F.5刷题测试

![image-20241212210803079](./assets/image-20241212210803079.png)

### G.替换算法

#### G.1替换操作是完全通过硬件完成的(此处无内容只是提醒你！)

#### G.2随机替换

![image-20241212211154063](./assets/image-20241212211154063.png)

#### G.3先进先出

#### G.4LRU（重点中的重点）

> LRU算法是面试手撕的重点题目
>
> 你可以在脑中模拟：
>
> 访问LRU中不存在元素：当前仅有4行 ，分别存储ABCD，且A在第0行。现在传入E，则将D删去，将C移到原来D的位置，感性认识就是下图中的某一列统一下移。
>
> 访问LRU中存在元素：题设如上，现在访问C，则新的顺序是CABD。也就是将C抽取到最近访问的上层，然后余下的字母依次下移。
>
> 

![image-20241212211308807](./assets/image-20241212211308807.png)

![image-20241212211752692](./assets/image-20241212211752692.png)

> 在直接映射下没有替换位：因为直接映射中，主存块和Cache块是一一对应的。

#### G.5LFU

> 给每一个被访问的元素计数。
>
> 优先替换出访问次数少的元素，如果两个元素访问次数相同，则优先替换出行号小的元素。

![image-20241212211935428](./assets/image-20241212211935428.png)

### H.一致性问题

#### H.1写命中

> 写命中问题：如果你是Javaer，我相信你会在各种Jvm分析文章中看到全写法与写回法。
>
> 

![image-20241212212133551](./assets/image-20241212212133551.png)

![image-20241212212321004](./assets/image-20241212212321004.png)

#### H.2写未命中

![image-20241212212430759](./assets/image-20241212212430759.png)

![image-20241212212509511](./assets/image-20241212212509511.png)

![image-20241212212618094](./assets/image-20241212212618094.png)

### I.多级Cache

## 4.1指令系统概述

### A.基本格式：

![image-20241212212852173](./assets/image-20241212212852173.png)

### B.地址码分类

![image-20241212212913762](./assets/image-20241212212913762.png)

### C.扩展操作码

![image-20241212212948951](./assets/image-20241212212948951.png)

## 4.2指令寻址和数据寻址(选择题)

### A.指令寻址

#### A.1顺序寻址

![image-20241212213142527](./assets/image-20241212213142527.png)

#### A.2跳跃寻址

![image-20241212213207409](./assets/image-20241212213207409.png)

### B.数据寻址

![image-20241212213310332](./assets/image-20241212213310332.png)

## 4.3程序的机器级代码表示(看得懂汇编)

### A.x86架构(重点)

#### A.1基本结构：

##### A.1.1通用寄存器：

![image-20241212213815366](./assets/image-20241212213815366.png)

##### A.1.2指令指令寄存器：

![image-20241212213843996](./assets/image-20241212213843996.png)

##### A.1.3标志寄存器：

![image-20241212213858065](./assets/image-20241212213858065.png)

#### A.2汇编语言：

![image-20241212213931816](./assets/image-20241212213931816.png)

#### A.3过程调用（难但是考的少）：

![image-20241212214035004](./assets/image-20241212214035004.png)

![image-20241212214100686](./assets/image-20241212214100686.png)

### B.Mips架构(mi连读)

#### B.1基本结构

> Mips架构涉及到了指令流水线，将程序的执行分为五个阶段
>
> 取指->译码->执行->访存->写回

![image-20241212214224180](./assets/image-20241212214224180.png)

#### B.2汇编语言

> 指令都是8个字节or都是4个字节->知道是Mips架构了

![image-20241212214326825](./assets/image-20241212214326825.png)

![image-20241212214437172](./assets/image-20241212214437172.png)

## 4.4CISC和RISC的基本概念

> 复杂指令集与精简指令集
>
> CISC就是X86 
>
> RISC就是Mips

![image-20241212214617465](./assets/image-20241212214617465.png)

## 5.1CPU的基本功能和基本结构

### A.存储程序的工作方式

![image-20241213114354978](./assets/image-20241213114354978.png)

### B.基本结构

#### B.1控制器与运算器

![image-20241213114630718](./assets/image-20241213114630718.png)

#### B.2时序发生器

![image-20241213114715049](./assets/image-20241213114715049.png)

### C.汇编语言程序员可见的寄存器

![image-20241213114756402](./assets/image-20241213114756402.png)

## 5.2指令执行过程

### A.一条指令的一般执行流程

![image-20241213114904654](./assets/image-20241213114904654.png)

### B.指令周期与机器周期

![image-20241213115226043](./assets/image-20241213115226043.png)

## 5.3数据通路的功能和结构



### A.数据通路是什么？

![image-20241213115403161](./assets/image-20241213115403161.png)

### B.数据通路中的元件

#### B.1操作元件(非时序逻辑)

![image-20241213115513082](./assets/image-20241213115513082.png)

#### B.2状态元件（时序逻辑-受到时钟信号的控制）

![image-20241213115547456](./assets/image-20241213115547456.png)

### C.时序控制

#### C.1早期的三级时序系统

![image-20241213115837212](./assets/image-20241213115837212.png)

#### C.2现代时序系统

![image-20241213115856099](./assets/image-20241213115856099.png)

### D.微操作序列

#### D.1什么是微操作

> 微操作：是比指令更基本，更小的操作步骤

![image-20241213120018002](./assets/image-20241213120018002.png)

#### D.2RTL语言描述微操作(寄存器传输语言)

![image-20241213120058541](./assets/image-20241213120058541.png)

#### D.3取指阶段的例子

![image-20241213120345425](./assets/image-20241213120345425.png)

### E.三种处理器

#### E.1单周期处理器

> 一个时钟周期完成一条指令

![image-20241213120543786](./assets/image-20241213120543786.png)

#### E.2多周期处理器

> 多个时钟周期完成一条指令

![image-20241213120638670](./assets/image-20241213120638670.png)

#### E.3流水线处理器

![image-20241213120745486](./assets/image-20241213120745486.png)

### F.两种数据通路

#### F.1专用数据通路

![image-20241213120819917](./assets/image-20241213120819917.png)

#### F.2总线数据通路

![image-20241213120839178](./assets/image-20241213120839178.png)

#### F.3真题测试

![image-20241213120912612](./assets/image-20241213120912612.png)

## 5.4控制器的功能和结构

### A.简单的CPU原理

> G是一个触发器：
>
> - G值为1：计算机正常运行 

![image-20241213124336310](./assets/image-20241213124336310.png)

### B.硬布线

![image-20241213124525085](./assets/image-20241213124525085.png)

![image-20241213124622860](./assets/image-20241213124622860.png)

### C.微程序

#### C.1基本原理

![image-20241213125036003](./assets/image-20241213125036003.png)

#### C.2基本组成

![image-20241213125141844](./assets/image-20241213125141844.png)

#### C.3微指令编码方式：

##### C3.1直接编码方式

![image-20241213125314987](./assets/image-20241213125314987.png)

##### C3.2字段直接编码方式

![image-20241213125415577](./assets/image-20241213125415577.png)

![image-20241213125448961](./assets/image-20241213125448961.png)

##### C3.3字段间接编码方式

![image-20241213125504022](./assets/image-20241213125504022.png)

##### C3.4最短编码方式

![image-20241213125516354](./assets/image-20241213125516354.png)

#### C.4微地址的形成方式

##### C.4.1增量方式

![image-20241213125723432](./assets/image-20241213125723432.png)

##### C.4.2断定方式

![image-20241213125733987](./assets/image-20241213125733987.png)

#### C.5微指令的格式

##### C.5.1水平型

![image-20241213125837814](./assets/image-20241213125837814.png)

##### C.5.2垂直型

![image-20241213125852782](./assets/image-20241213125852782.png)

![image-20241213125904305](./assets/image-20241213125904305.png)

### D.硬布线和微程序的比较

![image-20241213125930957](./assets/image-20241213125930957.png)

## 5.5异常与中断

### A.中断处理流程（这里简单提到）

![image-20241214185855130](./assets/image-20241214185855130.png)

### B.中断分类

![image-20241214185907198](./assets/image-20241214185907198.png)

## 5.6指令流水线

### A.五段式指令流水线基本原理

#### A.1五个阶段

![image-20241214190452348](./assets/image-20241214190452348.png)

#### A.2流水线过程

![image-20241214190748723](./assets/image-20241214190748723.png)

### B.性能指标

#### B.1吞吐率

![image-20241214191125646](./assets/image-20241214191125646.png)

#### B.2加速比

![image-20241214191159386](./assets/image-20241214191159386.png)

#### B.3流水段效率

![image-20241214191249968](./assets/image-20241214191249968.png)

### C.MIPS32流水线数据通路

![image-20241214191306240](./assets/image-20241214191306240.png)

### D.五段式流水线常用指令

#### D.1 load/store

![image-20241214191727121](./assets/image-20241214191727121.png)

#### D.2 R型算逻运算指令

![image-20241214191845963](./assets/image-20241214191845963.png)

#### D.3 I型算逻运算类指令

![image-20241214191949498](./assets/image-20241214191949498.png)

#### D.4 条件转移指令

![image-20241214192013601](./assets/image-20241214192013601.png)

![image-20241214192043598](./assets/image-20241214192043598.png)

### E.三种冒险(五段式考的少,三种冒险考的多)

#### E.1资源相关

![image-20241214192156398](./assets/image-20241214192156398.png) 

#### E.2数据相关

![image-20241214192249391](./assets/image-20241214192249391.png)

##### E.2.1解决办法-插入空操作

![image-20241214192511461](./assets/image-20241214192511461.png)

##### E.2.1解决办法-插入气泡(一个时钟周期)

![image-20241214192620083](./assets/image-20241214192620083.png)

##### E.2.1解决办法-转发技术

![image-20241214192724232](./assets/image-20241214192724232.png)

#### E.3控制相关(转移指令)

![image-20241214192750286](./assets/image-20241214192750286.png)

![image-20241214192843951](./assets/image-20241214192843951.png) 

### F.超流水线技术

![image-20241214192855033](./assets/image-20241214192855033.png)

## 6.1总结概述

### A.定义：

![image-20241214193919298](./assets/image-20241214193919298.png)

### B.基本特性:

#### B.1机械

![image-20241214193951035](./assets/image-20241214193951035.png)

#### B.2电气

![image-20241214194004562](./assets/image-20241214194004562.png)

#### B.3功能

![image-20241214194038529](./assets/image-20241214194038529.png)

#### B.4时序

![image-20241214194048193](./assets/image-20241214194048193.png)

### C.分类

#### C.1片内总线

![image-20241214194148072](./assets/image-20241214194148072.png)

#### C.2系统总线

![image-20241214194157724](./assets/image-20241214194157724.png)

#### C.3IO总线

![image-20241214194204579](./assets/image-20241214194204579.png)

#### C.4通信总线

![image-20241214194214573](./assets/image-20241214194214573.png)

### D.系统总线的结构

#### D.1 单总线

**定义：** 单总线（Single Bus）系统是一种简化的计算机内部结构，所有硬件设备（如CPU、内存、I/O设备等）共享一条总线进行通信。通常，这条总线包括数据线、地址线和控制线，负责连接不同的组件。

**完善说明：** 在单总线系统中，I/O总线、主存总线和DMA总线通常是共享的。即使不同设备需要不同的资源（如I/O设备、内存访问或DMA操作），它们都需要通过同一条总线进行访问。这种结构虽然简单，但由于所有设备共享一条总线，容易发生冲突，导致通信效率较低。

**特点：**

- **资源共享：** 所有设备共享I/O总线、主存总线和DMA总线，导致传输过程中容易出现瓶颈和冲突。
- **设计简单：** 总线数量较少，硬件成本较低。
- **传输速度受限：** 由于总线共享，数据传输速率受到限制，系统性能受到制约。
- **适用场景：** 适用于资源较少、性能要求不高的简单计算机系统。

------

#### D.2 双总线

**定义：** 双总线（Dual Bus）系统是指计算机内部采用两条总线来分别传输数据和地址信号。这种结构通常可以将I/O设备和主存的访问分开，提高了总线使用效率。

**完善说明：** 在双总线结构中，系统通常有一条主存总线和一条I/O总线。这样，主存和I/O设备的访问可以同时进行，避免了访问冲突。为了进一步提高性能，一些系统可能还会增加DMA总线，用于直接内存访问（DMA）操作，这使得数据能够直接在I/O设备和内存之间传输，减少了CPU的干预和总线的竞争。

**特点：**

- **并行访问：** 主存和I/O设备使用不同的总线进行访问，可以提高总线的并行性，减少访问冲突。
- **性能提升：** 分开使用主存总线和I/O总线后，系统的吞吐量和响应时间得到了改进。
- **支持DMA：** DMA总线可以专门用于内存和I/O设备之间的高速数据传输，进一步优化性能。
- **适用场景：** 适用于中等性能需求的计算机，常见于早期的个人计算机或嵌入式系统。

------

#### D.3 三总线

**定义：** 三总线（Triple Bus）系统是指计算机内部使用三条独立的总线，通常包括I/O总线、主存总线和DMA总线。这种结构使得系统能够更高效地处理不同类型的通信任务，通过专门的总线分担各个部分的负载。

**完善说明：** 在三总线结构中，I/O总线、主存总线和DMA总线是完全独立的。主存总线负责CPU与内存之间的数据交换，I/O总线负责CPU与外部设备（如硬盘、键盘、显示器等）之间的通信，而DMA总线则允许I/O设备直接与内存进行数据传输，避免了CPU的干预，从而提升了系统的整体性能。

**特点：**

- **高效并行处理：** 由于I/O、主存和DMA各自拥有独立的总线，它们能够同时并行工作，大大提高了系统的带宽和效率。
- **减少总线冲突：** 每个模块都有独立的总线，不再需要共享资源，减少了访问冲突和瓶颈。
- **支持复杂操作：** 三总线系统能够更好地支持复杂的操作，如同时进行数据传输、内存访问和DMA传输。
- **适用场景：** 适用于高性能计算机系统和现代的多任务、多处理器环境，如服务器、工作站等。

### E.性能指标(常考)

![image-20241214194303591](./assets/image-20241214194303591.png)

## 6.2总线事务

### A.定义

![image-20241214194533498](./assets/image-20241214194533498.png)

### B.数据传输方式(突发与非突发)

![image-20241214194629131](./assets/image-20241214194629131.png)

![image-20241214194648028](./assets/image-20241214194648028.png)

### C.总线定时 

#### C.1同步：统一的时钟

#### C.2异步：握手信号

> 可靠性差的速度快
>
> 不互锁 半互锁 全互锁 

![image-20241214194812367](./assets/image-20241214194812367.png)

#### C.3半同步：基于同步+wait信号

![image-20241214194908757](./assets/image-20241214194908757.png)

#### C.4分离式：分离式

![image-20241214195000409](./assets/image-20241214195000409.png)
