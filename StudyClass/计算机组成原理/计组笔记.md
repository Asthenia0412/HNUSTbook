
## 3.1存储器概述
### A.按存取方式分：
- RAM
- ROM
- SAM（顺序-磁带）
- DAM（直接-磁盘存储器）
### B.断电后是否保存：
- 易失性：断电后存储信息消失，如RAM
- 非易失性：断电后存储信息依旧保存，如ROM、磁盘、磁带、光盘
### C.读出方式：
- 破坏性读出：DRAM
- 非破坏性读出：SRAM
### D.性能指标：
#### D.1储存单元：
- 存储字：一个二进制由若干位组成，这个二进制数作为整体存入或者取出，这个数就是存储字，存储字的长度取决于MDR。
- 存储单元：存储体的组成单位。存储单元的个数取决于MAR的次方。
- 一个存储单元可以存放一个字，也可以存放一个字节。
#### D.2编址和寻址：
- 地址：存储单元的编号，用于区别存储体中的若干存储单元。
- 编址：给每个房间编号
  - 字节编址：最小寻址单位是一个字节。
  - 字编址：最小寻址单元是一个字。
- 寻址：根据地址找到存储单元的过程。
#### D.3存储容量：
- 存储单元的个数 x 每个单元的比特数（如果是按字节编址则为存储单元个数x8，如果是按字编址则为存储单元个数x字中的比特数）。
#### D.4存取时间（很少用）：
- T_A：存储器接到读命令到信息被送到数据线上的时间。
- T_W：存储器接到写命令到信息被写入存储器的时间。
#### D.5存取周期（T_M）：
- T_M > T_A
- T_M > T_W
- 一个访问时间与一个恢复时间构成一个存取周期。
## 3.2主存：
### A.DRAM工作原理：

- 写入：MOS管接通+电容存入电荷。
- 读出：MOS管放开+电容电荷流失+信号放大器感知+计算机了解该位数据已读出。
- 问题：读出是破坏性的，因此需要再生。
### B.DRAM VS SRAM：
| 特征       | SRAM         | DRAM       |
| ---------- | ------------ | ---------- |
| 构成       | 双稳态触发器 | 电容       |
| 破坏性读出 | 否           | 是         |
| 再生       | 不需要       | 需要       |
| 易失性     | 是           | 是         |
| 送行列地址 | 同时送       | 行列分开送 |
| 地址复用   | 否           | 是         |
| 速度       | 快           | 慢         |
| 刷新       | 不需要       | 需要       |
| 集成度     | 低           | 高         |
| 功耗       | 高           | 低         |
| 价格       | 高           | 低         |
### C.半导体存储芯片：

![image-20241212190116335](./assets/image-20241212190116335.png)

![image-20241212190105872](./assets/image-20241212190105872-1734001266987-1.png)

![image-20241212190253813](./assets/image-20241212190253813.png)

- 基本结构：译码驱动电路 -> 存储矩阵 -> 读写电路
  - 译码驱动电路：与地址线连接，负责将地址信号转换为特定存储单元选择信号。
  - 存储矩阵：存储单元的集合。
  - 读写电路：与数据线连接，负责写入或读取数据。
  - 外部相联：
    - 片选线：单向，负责选定要访问的存储器芯片。
    - 读写控制线：单向，负责下达读写命令。
    - 数据线：双向，传递数据。
    - 地址线：单向，将地址传入译码器。
- 译码驱动方式（重要）：
        - 单译码法(线选法)：地址译码器仅有一个
          - 通过n个地址引脚定义一个大小为2^n的地址空间
          - 地址输入线的引脚n=4，经过地址译码器译码，有2^4一共16个状态，对应16个地址。则存储单元的地址为000B~111B
          - 译码后输出的线过多，因此只适合**容量小**的**静态存储器**
      - 双译码法(重合法)：
        - 建立笛卡尔坐标系，实数对(X,Y)唯一确定1个存储单元。X由行地址译码驱动，Y由列地址译码驱动。
        - 输入端为n根引脚，有n/2根行地址线，也就是有2^(n/2)行，有n/2根列地址线，也就是 2^(n/2)列。因此，输出端引脚只需要 2^(n/2)+1个。适合大容量的动态存储器
        - 行缓冲：
        - 位平面：

### D.DRAM的刷新：

#### D.1为什么DRAM要刷新？

因为DRAM的本质是一个MOS管+电容，电容会漏电，因此需要定期充电

#### D.2集中刷新

![image-20241212190534127](./assets/image-20241212190534127.png)

#### D.3分散刷新

![image-20241212190553640](./assets/image-20241212190553640.png)

#### D.4异步刷新

![image-20241212190606846](./assets/image-20241212190606846.png)

## 3.3主存容量扩展以及并行技术

### A.扩展技术

#### A.1位扩展：

![image-20241212194252562](./assets/image-20241212194252562.png)

我的需求是：256k x 8

但是我只有八块256k x 1的芯片，那么我会在横向上进行拼接

#### A.2字扩展：

如何理解字：存储体中存储单元的个数。

![image-20241212194553006](./assets/image-20241212194553006.png)

![image-20241212194659484](./assets/image-20241212194659484.png)

#### A.3字位扩展

![image-20241212194740076](./assets/image-20241212194740076.png)

![image-20241212194805777](./assets/image-20241212194805777.png)

### B.并行技术

#### B.1双端口

![image-20241212194843231](./assets/image-20241212194843231.png)

#### B.2单体多字存储器

![image-20241212194929735](./assets/image-20241212194929735.png)

#### B.3交叉访问存储器-模块访问

##### B.3.1高位多体交叉

![image-20241212195144916](./assets/image-20241212195144916.png)

##### B.3.2低位多体交叉(重要)

![image-20241212195228064](./assets/image-20241212195228064.png)

##### B.3.3轮流启动

![image-20241212195430414](./assets/image-20241212195430414.png)

##### B.3.4同时启动

![image-20241212195529048](./assets/image-20241212195529048.png)

### C.字位扩展技术与并行技术总结

![image-20241212195559713](./assets/image-20241212195559713.png)

## 3.4外部存储器

### A.磁盘存储

#### A.1组成

**盘片、盘面**

![image-20241212201151008](./assets/image-20241212201151008.png)

**盘面与扇区**

![image-20241212201211836](./assets/image-20241212201211836.png)

**磁头臂**

![image-20241212201631815](./assets/image-20241212201631815.png)

#### A.2存取时间

![image-20241212201646222](./assets/image-20241212201646222.png)

#### A.3地址结构

![image-20241212201803146](./assets/image-20241212201803146.png)

### B.固态硬盘

#### B.1基本结构与工作原理

![image-20241212201929823](./assets/image-20241212201929823.png)

#### B.2读写原理

![image-20241212202035071](./assets/image-20241212202035071.png)

#### B.3磨损均衡技术

原因是：不希望某一块闪存中的块被反复擦除(因为SSD写入需要擦除旧的内容)

![image-20241212202215611](./assets/image-20241212202215611.png)

### C.二者比较

![image-20241212202306823](./assets/image-20241212202306823.png)

## 3.5高速缓存处理器

### A.程序访问的局部性原理

![image-20241212205213141](./assets/image-20241212205213141.png)

![image-20241212205240919](./assets/image-20241212205240919.png)

### B.cache与主存块 

> Cache的一个块：对应存储体中的多个存储单元

![image-20241212205331638](./assets/image-20241212205331638.png)

### C.cache的有效位

> Cache的有效位：解决Cache和主存中的数据不一致问题
>
> 在每一个Cache块前都用有效位表示：
>
> 其中有效位为1表示：当前Cache的值和主存中是一致的
>
> 其中有效位为0表示：当前Cache中的值和主存的值是不一样的！

![image-20241212205508311](./assets/image-20241212205508311.png)

### D.cache的访问过程

![image-20241212205655655](./assets/image-20241212205655655.png)

### E.cache-主存层次的访问时间

> CPU在cache-主存层次的平均访问时间公式记忆：
>
> T=命中率x命中时间+缺失率x缺失时间
>
> 切记缺失时间是（T_m+T_c）

![image-20241212205811547](./assets/image-20241212205811547.png)

### F.映射方式

> 这一块的难点是：
>
> 1.你得记住不同映射标准下的地址划分标准，也就是给你一个二进制表达的数字串，你要能区分出哪几位是标记，那几位是行号or其他的特性
>
> 2.你这的地址划分是对主存地址的划分，是主存！是主存！是主存！！！！

#### F.1直接映射

> 直接映射：
>
> 任何一个主存块只能映射到**特定的Cache行**中
>
> 标记也叫Tag

![image-20241212210213771](./assets/image-20241212210213771.png)

#### F.2全相联

> 你好像发觉了：在全相联映射中，没有Cache行号的概念了！
>
> 你的猜想没错，全相联映射的主存块可以映射到任意的Cache行中，因此Cache行号失去了存在的价值

![image-20241212210403037](./assets/image-20241212210403037.png)

#### F.3组相连

> 组相联的结构和直接相联比较类似
>
> 但是有很大的一点差异：
>
> 组相联映射下的主存地址划分中：中间部分**并非**Cache**行号**，**而是**Cache**组号**。

![image-20241212210511996](./assets/image-20241212210511996.png)

#### F.4比较器个数

![image-20241212210720378](./assets/image-20241212210720378.png)

#### F.5刷题测试

![image-20241212210803079](./assets/image-20241212210803079.png)

### G.替换算法

#### G.1替换操作是完全通过硬件完成的(此处无内容只是提醒你！)

#### G.2随机替换

![image-20241212211154063](./assets/image-20241212211154063.png)

#### G.3先进先出

#### G.4LRU（重点中的重点）

> LRU算法是面试手撕的重点题目
>
> 你可以在脑中模拟：
>
> 访问LRU中不存在元素：当前仅有4行 ，分别存储ABCD，且A在第0行。现在传入E，则将D删去，将C移到原来D的位置，感性认识就是下图中的某一列统一下移。
>
> 访问LRU中存在元素：题设如上，现在访问C，则新的顺序是CABD。也就是将C抽取到最近访问的上层，然后余下的字母依次下移。
>
> 

![image-20241212211308807](./assets/image-20241212211308807.png)

![image-20241212211752692](./assets/image-20241212211752692.png)

> 在直接映射下没有替换位：因为直接映射中，主存块和Cache块是一一对应的。

#### G.5LFU

> 给每一个被访问的元素计数。
>
> 优先替换出访问次数少的元素，如果两个元素访问次数相同，则优先替换出行号小的元素。

![image-20241212211935428](./assets/image-20241212211935428.png)

### H.一致性问题

#### H.1写命中

> 写命中问题：如果你是Javaer，我相信你会在各种Jvm分析文章中看到全写法与写回法。
>
> 

![image-20241212212133551](./assets/image-20241212212133551.png)

![image-20241212212321004](./assets/image-20241212212321004.png)

#### H.2写未命中

![image-20241212212430759](./assets/image-20241212212430759.png)

![image-20241212212509511](./assets/image-20241212212509511.png)

![image-20241212212618094](./assets/image-20241212212618094.png)

### I.多级Cache

## 4.1指令系统概述

### A.基本格式：

![image-20241212212852173](./assets/image-20241212212852173.png)

### B.地址码分类

![image-20241212212913762](./assets/image-20241212212913762.png)

### C.扩展操作码

![image-20241212212948951](./assets/image-20241212212948951.png)

## 4.2指令寻址和数据寻址(选择题)

### A.指令寻址

#### A.1顺序寻址

![image-20241212213142527](./assets/image-20241212213142527.png)

#### A.2跳跃寻址

![image-20241212213207409](./assets/image-20241212213207409.png)

### B.数据寻址

![image-20241212213310332](./assets/image-20241212213310332.png)

## 4.3程序的机器级代码表示(看得懂汇编)

### A.x86架构(重点)

#### A.1基本结构：

##### A.1.1通用寄存器：

![image-20241212213815366](./assets/image-20241212213815366.png)

##### A.1.2指令指令寄存器：

![image-20241212213843996](./assets/image-20241212213843996.png)

##### A.1.3标志寄存器：

![image-20241212213858065](./assets/image-20241212213858065.png)

#### A.2汇编语言：

![image-20241212213931816](./assets/image-20241212213931816.png)

#### A.3过程调用（难但是考的少）：

![image-20241212214035004](./assets/image-20241212214035004.png)

![image-20241212214100686](./assets/image-20241212214100686.png)

### B.Mips架构(mi连读)

#### B.1基本结构

> Mips架构涉及到了指令流水线，将程序的执行分为五个阶段
>
> 取指->译码->执行->访存->写回

![image-20241212214224180](./assets/image-20241212214224180.png)

#### B.2汇编语言

> 指令都是8个字节or都是4个字节->知道是Mips架构了

![image-20241212214326825](./assets/image-20241212214326825.png)

![image-20241212214437172](./assets/image-20241212214437172.png)

## 4.4CISC和RISC的基本概念

> 复杂指令集与精简指令集
>
> CISC就是X86 
>
> RISC就是Mips

![image-20241212214617465](./assets/image-20241212214617465.png)

## 5.1CPU的基本功能和基本结构

## 5.2指令执行过程

## 5.3数据通路的功能和结构

## 5.4控制器的功能和结构

## 5.5异常与中断
