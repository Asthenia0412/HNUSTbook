# Redis过期删除策略与内存淘汰策略知识复习

## 一、过期键(expire)基础概念

### 场景：电商系统商品促销缓存

在电商系统中，商品促销信息（如`promo:1001`）设置了1小时过期时间，但发现部分缓存未及时清理，导致内存占用过高。

#### A. 为什么需要过期键？

过期键通过自动释放内存，控制数据时效性，确保缓存数据与业务需求一致。例如，促销活动结束后，过期键可防止用户访问失效数据，同时释放内存用于新数据。

#### B. 过期键结构与反馈

- 作用与意义

  ：

  - 自动释放内存：通过TTL机制清理无用数据。
  - 数据时效性：如促销信息仅在活动期间有效。
  - 缓存更新：支持定时刷新业务数据。

- 核心命令

  ：

  - `EXPIRE key seconds`：设置键的秒级过期时间。
  - `PEXPIRE key milliseconds`：毫秒级过期时间。
  - `EXPIREAT/PEXPIREAT`：指定绝对过期时间戳。
  - `TTL/PTTL`：查询剩余生存时间。
  - `PERSIST`：移除过期时间。

- 用户看到的反馈

  ：

  - 查询TTL：

    ```
    redis-cli> TTL promo:1001
    (integer) 3600  # 1小时
    ```

  - 过期后键自动消失：

    ```
    redis-cli> GET promo:1001
    (nil)
    ```

- 实战操作

  ：

  1. 设置过期时间：

     ```bash
     redis-cli SET promo:1001 "{\"id\":1001,\"discount\":0.8}"
     redis-cli EXPIRE promo:1001 3600
     ```

  2. 检查TTL：

     ```bash
     redis-cli TTL promo:1001
     ```

  3. 移除过期：

     ```bash
     redis-cli PERSIST promo:1001
     ```

#### C. 面试深入考察应对

1. Q1：TTL的精度如何保证？
   - 答：Redis使用Unix时间戳，`PEXPIRE`支持毫秒级精度，适合高精度场景。需注意系统时钟同步（如NTP）。
   - 深入Q2：大量键同时过期会有什么问题？
     - 答：可能引发“过期风暴”，导致定期删除任务阻塞主线程。解决方法：设置随机TTL（如3600±100秒）分散过期时间。
     - 深入Q3：如何优化过期键管理？
       - 答：结合业务设置合理TTL；使用`SCAN`批量检查过期键；监控`expired_keys`指标，调整`hz`参数。

------

## 二、过期键删除策略

### 场景：社交平台用户会话管理

用户会话（如`session:1001`）设置7天过期，但内存占用未及时下降，影响Redis性能。

#### A. 为什么需要删除策略？

过期键若不及时清理，会占用内存，降低Redis性能。合理删除策略平衡CPU和内存回收效率。

#### B. 删除策略结构与反馈

- 被动删除（惰性删除）

  ：

  - 触发：访问键时检查是否过期。
  - 原理：命令执行前检查TTL，若过期则删除。
  - 优点：CPU开销低，仅在访问时处理。
  - 缺点：内存回收不及时，可能累积大量过期键。

- 主动删除（定期删除）

  ：

  - 流程：Redis定时任务（`hz`控制频率）采样检查键。
  - 自适应调整：根据过期键比例动态调整采样量。
  - 平衡：高`hz`回收快但CPU开销大。

- 混合删除

  ：

  - 结合惰性和定期删除，定期任务清理大部分过期键，访问时补充清理。

- 用户看到的反馈

  ：

  - ```
    INFO STATS
    ```

    显示过期键清理：

    ```
    expired_keys: 1000
    ```

  - 内存占用下降：

    ```
    redis-cli> INFO MEMORY
    used_memory: 52428800  # 50MB
    ```

- 实战操作

  ：

  1. 检查过期键统计：

     ```bash
     redis-cli INFO STATS
     ```

  2. 调整

     ```
     hz
     ```

     参数：

     ```bash
     redis-cli CONFIG SET hz 20
     ```

  3. 监控内存：

     ```bash
     redis-cli INFO MEMORY
     ```

#### C. 面试深入考察应对

1. Q1：如何优化定期删除性能？
   - 答：调整`hz`参数（如10-20），增加采样频率；监控`expired_keys`指标，评估清理效率。
   - 深入Q2：惰性删除的局限性？
     - 答：未访问的过期键可能长期占用内存，需依赖定期删除补充。定期任务不足时，需手动触发清理（如`SCAN`）。
     - 深入Q3：如何处理过期风暴？
       - 答：设置随机TTL分散过期时间；降低`hz`减少单次任务开销；使用从节点分担清理任务。

------

## 三、内存淘汰策略

### 场景：Redis缓存内存超限

Redis实例配置`maxmemory 1gb`，但促销活动期间内存超限，导致写入失败。

#### A. 为什么需要内存淘汰？

内存超限时，Redis需通过淘汰策略释放空间，保证新数据写入，避免服务不可用。

#### B. 淘汰策略结构与反馈

- 内存限制

  ：

  - `maxmemory`：设置最大内存（如`1gb`）。
  - 动态调整：`CONFIG SET maxmemory <bytes>`。

- 淘汰策略

  ：

  - `noeviction`：不淘汰，内存满时拒绝写入。
  - `allkeys-random`：随机淘汰所有键。
  - `allkeys-lru`：按最近最少使用淘汰。
  - `allkeys-lfu`：按访问频率淘汰。
  - `volatile-random/lru/lfu`：仅淘汰设置了TTL的键。
  - `volatile-ttl`：优先淘汰TTL较短的键。

- 选择指南

  ：

  - 缓存场景：`allkeys-lru`或`allkeys-lfu`。
  - 持久化场景：`volatile-lru`保护非过期键。

- 用户看到的反馈

  ：

  - 淘汰统计：

    ```
    redis-cli> INFO STATS
    evicted_keys: 500
    ```

  - 写入失败（

    ```
    noeviction
    ```

    ）：

    ```
    redis-cli> SET key value
    (error) OOM command not allowed when used_memory > 'maxmemory'
    ```

- 实战操作

  ：

  1. 设置内存限制：

     ```bash
     redis-cli CONFIG SET maxmemory 1gb
     ```

  2. 配置淘汰策略：

     ```bash
     redis-cli CONFIG SET maxmemory-policy allkeys-lru
     ```

  3. 监控淘汰：

     ```bash
     redis-cli INFO STATS
     ```

#### C. 面试深入考察应对

1. Q1：如何选择合适的淘汰策略？
   - 答：根据业务场景：缓存用`allkeys-lru`（热点数据优先保留）；持久化用`volatile-lru`（保护关键数据）；高频访问用`allkeys-lfu`。
   - 深入Q2：淘汰策略如何影响性能？
     - 答：LRU/LFU需维护访问信息，增加少量CPU开销；`noeviction`无淘汰开销但可能拒绝写入，需权衡。
     - 深入Q3：如何动态调整maxmemory？
       - 答：通过`CONFIG SET`动态调整，结合`INFO MEMORY`监控`used_memory`；自动化脚本根据负载调整。

------

## 四、LRU与LFU算法实现

### 场景：热点数据频繁淘汰

Redis使用`allkeys-lru`，但发现热点数据被意外淘汰，影响命中率。

#### A. 为什么需要关注算法实现？

LRU/LFU算法直接影响淘汰准确性，错误淘汰可能降低缓存命中率，增加数据库压力。

#### B. 算法结构与反馈

- 近似LRU

  ：

  - 挑战：传统LRU维护完整访问顺序开销大。
  - 实现：采样池（`maxmemory-samples`），随机抽样淘汰。
  - 平衡：采样量（如5-10）折中精度和性能。

- LFU

  ：

  - 计数器：记录访问频率（`counter`）。
  - 衰减：随时间降低频率（`lfu-decay-time`）。
  - 新对象保护：新键有初始频率，避免立即淘汰。

- 对比

  ：

  - LRU：适合访问分布均匀场景。
  - LFU：适合热点数据集中场景，精度更高。

- 用户看到的反馈

  ：

  - 命中率提升：

    ```
    redis-cli> INFO STATS
    keyspace_hits: 9000
    keyspace_misses: 1000
    ```

  - 淘汰日志：

    ```
    evicted_keys: 200
    ```

- 实战操作

  ：

  1. 配置LRU采样：

     ```bash
     redis-cli CONFIG SET maxmemory-samples 10
     ```

  2. 配置LFU衰减：

     ```bash
     redis-cli CONFIG SET lfu-decay-time 10
     ```

  3. 监控命中率：

     ```bash
     redis-cli INFO STATS
     ```

#### C. 面试深入考察应对

1. Q1：LRU采样池的局限性？
   - 答：采样量小可能误淘汰热点数据，采样量大增加CPU开销。需根据数据量调整`maxmemory-samples`。
   - 深入Q2：LFU如何处理访问频率突变？
     - 答：通过衰减机制（`lfu-decay-time`）平滑频率变化；新对象保护避免新键被快速淘汰。
     - 深入Q3：如何选择LRU还是LFU？
       - 答：分析访问模式：均匀访问用LRU，热点集中用LFU；测试命中率和淘汰效果。

------

## 五、内存管理高级主题

### 场景：Redis内存碎片高

Redis实例内存碎片率达1.5，导致可用内存不足，触发频繁淘汰。

#### A. 为什么需要高级内存管理？

内存碎片和淘汰过程影响性能，需优化以提升内存利用率和稳定性。

#### B. 高级主题结构与反馈

- 内存碎片

  ：

  - 监控：`mem_fragmentation_ratio`（>1.5需优化）。
  - 整理：重启实例或使用`jemalloc`优化。

- 淘汰性能

  ：

  - 阻塞：LRU/LFU计算可能增加延迟。
  - 集群：节点间内存不均需均衡。

- 持久化交互

  ：

  - RDB：忽略过期键，减少文件大小。
  - AOF：重写时清理过期键。
  - 主从同步：过期键不复制。

- 用户看到的反馈

  ：

  - 碎片率：

    ```
    redis-cli> INFO MEMORY
    mem_fragmentation_ratio: 1.50
    ```

  - 淘汰统计：

    ```
    evicted_keys: 300
    ```

- 实战操作

  ：

  1. 检查碎片：

     ```bash
     redis-cli INFO MEMORY
     ```

  2. 重启整理碎片：

     ```bash
     redis-cli SHUTDOWN && redis-server /etc/redis.conf
     ```

  3. 启用AOF重写：

     ```bash
     redis-cli BGREWRITEAOF
     ```

#### C. 面试深入考察应对

1. Q1：如何降低内存碎片？
   - 答：使用`jemalloc`分配器；定期重启实例；调整键大小分布。
   - 深入Q2：集群环境下如何平衡内存？
     - 答：使用`CLUSTER REBALANCE`重新分配槽；监控节点`used_memory`差异。
     - 深入Q3：持久化如何影响过期键？
       - 答：RDB不保存过期键，AOF重写清理过期键；需确保主从同步一致性。

------

## 六、实战配置与优化

### 场景：Redis缓存性能下降

Redis缓存命中率下降，`evicted_keys`增加，需优化配置。

#### A. 为什么需要优化配置？

合理配置可提升命中率，降低淘汰频率，保障性能。

#### B. 配置与优化结构

- 配置模板

  ：

  - 缓存场景：`maxmemory-policy allkeys-lru`, `hz 20`.
  - 持久化场景：`volatile-lru`, `save 60 1000`.

- 监控指标

  ：

  - `evicted_keys`：淘汰键数量。
  - `expired_keys`：过期键清理。
  - `mem_fragmentation_ratio`：碎片率。
  - `keyspace_hits/misses`：命中率。

- 调优案例

  ：

  - 内存突增：切换`allkeys-lfu`。
  - 过期优化：设置随机TTL。

- 用户看到的反馈

  ：

  - 命中率提升：

    ```
    keyspace_hits: 9500
    keyspace_misses: 500
    ```

  - 碎片率下降：

    ```
    mem_fragmentation_ratio: 1.10
    ```

- 实战操作

  ：

  1. 配置LFU：

     ```bash
     redis-cli CONFIG SET maxmemory-policy allkeys-lfu
     ```

  2. 设置随机TTL（Lua脚本）：

     ```lua
     redis.call('EXPIRE', KEYS[1], 3600 + math.random(-100, 100))
     ```

  3. 监控指标：

     ```bash
     redis-cli INFO STATS
     ```

#### C. 面试深入考察应对

1. Q1：如何处理命中率低？
   - 答：分析`keyspace_misses`，调整淘汰策略（如`allkeys-lfu`）；增加`maxmemory`。
   - 深入Q2：随机TTL的实现方式？
     - 答：通过客户端或Lua脚本为键设置随机偏移TTL，分散过期时间。
     - 深入Q3：如何自动化调优？
       - 答：使用脚本监控`INFO`指标，动态调整`hz`或`maxmemory-policy`；集成Prometheus告警。

------

## 七、特殊场景处理

### 场景：大键淘汰导致延迟

Redis淘汰大键（如Hash包含10万field）导致主线程阻塞。

#### A. 为什么需要特殊处理？

大键淘汰和集群环境可能引发性能问题，需针对性优化。

#### B. 特殊场景结构

- 大键淘汰

  ：

  - 挑战：大键删除耗时长，阻塞主线程。
  - 方案：渐进式删除（如`HSCAN`+`HDEL`）。

- 集群环境

  ：

  - 内存平衡：节点间`used_memory`差异。
  - 跨槽键：需分片处理。

- 生产陷阱

  ：

  - 过期风暴：集中过期阻塞。
  - 客户端缓冲：命令堆积。

- 用户看到的反馈

  ：

  - 慢查询记录：

    ```
    redis-cli> SLOWLOG GET
    1) 1) (integer) 1234
       2) (integer) 1698765432
       3) (integer) 10000  # 10ms
       4) 1) "DEL" "bigkey:1001"
    ```

- 实战操作

  ：

  1. 渐进式删除：

     ```bash
     redis-cli HSCAN bigkey:1001 0 COUNT 1000 | xargs redis-cli HDEL bigkey:1001
     ```

  2. 平衡集群：

     ```bash
     redis-cli CLUSTER REBALANCE
     ```

  3. 检查客户端缓冲：

     ```bash
     redis-cli INFO CLIENTS
     ```

#### C. 面试深入考察应对

1. Q1：如何优化大键淘汰？
   - 答：使用`UNLINK`异步删除；分批删除（如`HDEL`每次1000个field）。
   - 深入Q2：过期风暴的应急处理？
     - 答：降低`hz`减少任务开销；临时增加`maxmemory`；分散TTL。
     - 深入Q3：集群跨槽键如何处理？
       - 答：通过`CLUSTER KEYSLOT`定位槽，分片存储；使用代理（如Twemproxy）简化访问。

------

## 八、版本演进对比

### 场景：升级Redis以优化内存管理

公司计划从Redis 4.0升级到7.0，需评估内存管理改进。

#### A. 为什么需要关注版本演进？

新版本提供更高效的淘汰和碎片管理，提升内存利用率。

#### B. 版本演进结构

- Redis 4.0

  ：

  - 引入LFU算法。
  - 增强`MEMORY`命令（如`MEMORY USAGE`）。

- Redis 6.0+

  ：

  - 淘汰并行化：多线程I/O加速。
  - 内存效率：优化数据结构存储。

- Redis 7.0+

  ：

  - 精确内存控制：更细粒度配置。
  - 碎片整理：改进`jemalloc`性能。

- 用户看到的反馈

  ：

  - 碎片率降低：

    ```
    mem_fragmentation_ratio: 1.05
    ```

  - 淘汰效率提升：

    ```
    evicted_keys: 100
    ```

- 实战操作

  ：

  1. 检查内存使用：

     ```bash
     redis-cli MEMORY USAGE promo:1001
     ```

  2. 启用多线程：

     ```bash
     redis-cli CONFIG SET io-threads 4
     ```

#### C. 面试深入考察应对

1. Q1：LFU如何提升淘汰精度？
   - 答：通过频率计数器和衰减机制，优先保留高频键，适合热点场景。
   - 深入Q2：多线程I/O对淘汰的影响？
     - 答：加速淘汰数据传输，但逻辑计算仍单线程，需结合分片优化。
     - 深入Q3：碎片整理的注意事项？
       - 答：避免高峰期整理；监控`mem_fragmentation_ratio`；测试`jemalloc`配置。