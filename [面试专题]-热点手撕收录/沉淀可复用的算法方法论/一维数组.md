## 一：数组原地不变,通过设计索引来表达不同子数组

给定一个非负整数数组 `nums`， `nums` 中一半整数是 **奇数** ，一半整数是 **偶数** 。

对数组进行排序，以便当 `nums[i]` 为奇数时，`i` 也是 **奇数** ；当 `nums[i]` 为偶数时， `i` 也是 **偶数** 。

你可以返回 *任何满足上述条件的数组作为答案* 。

**示例 1：**

```
输入：nums = [4,2,5,7]
输出：[4,5,2,7]
解释：[4,7,2,5]，[2,5,4,7]，[2,7,4,5] 也会被接受。
```

**示例 2：**

```
输入：nums = [2,3]
输出：[2,3]
```

```java
class Solution {
    public int[] sortArrayByParityII(int[] nums) {
        int i = 0;//0索引表示偶数数组的下标
        int j = 1;//1索引表示奇数数组的下标
        while(i<nums.length){
            if(nums[i]%2==0){
                i+=2;
            }else if(nums[j]%2==1){
                j+=2;
            }else{
                int tmp = nums[i];
                nums[i] = nums[j];
                nums[j] = tmp;
                i+=2;
                j+=2;
            }
        }
        return nums;
        
    }
}
```

> 1. **需求分析**：
>
>    - 给定一个整数数组 `nums`，要求将数组中的偶数和奇数按照特定顺序进行排序，即偶数出现在数组的偶数下标位置（0, 2, 4, ...），奇数出现在数组的奇数下标位置（1, 3, 5, ...）。
>    - 假设输入的数组中，偶数和奇数的数量是相等的。
>
> 2. **算法选型**：
>
>    - 采用双指针的方式进行排序：一个指针 `i` 用于遍历偶数应该在的位置，另一个指针 `j` 用于遍历奇数应该在的位置。
>    - 双指针可以通过分别遍历偶数和奇数的位置来交换不符合要求的元素，直至所有元素都在正确的位置。
>
> 3. **逻辑实现**：
>
>    - 初始化两个指针：`i` 用于指向偶数应在的位置（从索引 0 开始），`j` 用于指向奇数应在的位置（从索引 1 开始）。
>
>    - 进入
>
>       
>
>      ```
>      while
>      ```
>
>       
>
>      循环，条件是
>
>       
>
>      ```
>      i
>      ```
>
>       
>
>      小于数组长度。在循环内部：
>
>      - 如果当前位置的元素 `nums[i]` 是偶数（即 `nums[i] % 2 == 0`），则将 `i` 向后移动两个位置（跳到下一个偶数位置）。
>      - 如果 `nums[j]` 是奇数（即 `nums[j] % 2 == 1`），则将 `j` 向后移动两个位置（跳到下一个奇数位置）。
>      - 如果 `nums[i]` 是奇数且 `nums[j]` 是偶数，说明当前这两个元素的位置不符合要求，因此交换这两个元素，并同时将 `i` 和 `j` 向后移动两个位置，继续检查下一个元素。
>
>    - 循环结束时，所有偶数已经排布到偶数下标位置，奇数也排布到奇数下标位置。
>
>    - 最终返回排序后的数组 `nums`。