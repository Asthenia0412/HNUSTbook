# 记忆并理解

## 1.编译程序五阶段的划分与作用

编译程序通常被划分为五个主要阶段，每个阶段负责将源代码逐步转换为目标代码。以下是各阶段的详细划分及其作用：

------

### 1. **词法分析（Lexical Analysis）**

- **作用**：将源代码字符流分解为有意义的词法单元（Token）。

- 

  关键任务：

  - 识别**标识符、关键字、运算符、常量**等。
  - 过滤**空白符**、**注释**等无关内容。
  - 生成符号表（Symbol Table）的初始条目。

- **输出**：Token 序列（如 `[type: ID, value: "x"]`）。

- **工具示例**：Lex、Flex。

**示例**：
 代码 `int x = 42;` 会被分解为：
 `[type: KEYWORD, value: "int"]`、`[type: ID, value: "x"]`、`[type: OPERATOR, value: "="]`、`[type: CONST, value: 42]`。

------

### 2. **语法分析（Syntax Analysis）**

- **作用**：根据语法规则验证 Token 序列的结构，生成抽象语法树（AST）。

- 

  关键任务：

  - 检查语法错误（如缺少分号、括号不匹配）。
  - 构建层次化的语法结构（如表达式、语句、函数）。

- **输出**：抽象语法树（AST）。

- **工具示例**：Yacc、Bison。

**示例**：
 `x = 42 + y` 的 AST 可能表示为：

```
    (=)
   /   \
  x    (+)
      /   \
    42     y
```

------

### 3. **语义分析（Semantic Analysis）**

- **作用**：分析程序的语义正确性，补充类型和上下文信息。

- 

  关键任务：

  - 类型检查（如变量类型匹配、运算符合法性）。
  - 作用域分析（变量是否声明、是否重复定义）。
  - 符号表填充（记录变量类型、作用域等属性）。

- **输出**：带标注的 AST（附加类型和作用域信息）。

**示例**：
 若 `y` 未声明，报错：`Error: Undefined variable 'y'`。

------

### 4. **中间代码生成（Intermediate Code Generation）**

- **作用**：生成与机器无关的中间表示（IR），便于优化和跨平台。
- 关键任务：
  - 将 **AST** 转换为**三地址码、四元式或虚拟机指令**（如 LLVM IR）。
  - 简化后续优化和翻译过程。
- **输出**：中间代码（如三地址码）。

**示例**：
 `x = 42 + y` 的三地址码：

```
t1 = 42 + y  
x = t1
```

------

### 5. **代码优化与目标代码生成**

#### **代码优化（可选）**

- **作用**：提高目标代码的效率（速度/空间）。
- 优化类型：
  - **局部优化**：常量折叠、死代码删除。
  - **全局优化**：循环优化、内联展开。

**示例**：
 `x = 2 * 3` → 优化为 `x = 6`（常量折叠）。

#### **目标代码生成**

- **作用**：将中间代码转换为目标机器代码（汇编或二进制）。

- 

  关键任务

  ：

  - 寄存器分配（如使用图着色算法）。
  - 指令选择（匹配机器指令集）。
  - 处理平台相关细节（调用约定、内存对齐）。

- **输出**：目标代码（如 x86 汇编或 JVM 字节码）。

**示例**：
 三地址码 `x = t1` 可能生成：

```
mov eax, [t1]  
mov [x], eax
```

------

### 总结

| 阶段          | 输入         | 输出              | 核心任务                   |
| ------------- | ------------ | ----------------- | -------------------------- |
| 词法分析      | 源代码字符流 | Token 序列        | 分词、去冗余               |
| 语法分析      | Token 序列   | 抽象语法树（AST） | 检查语法结构               |
| 语义分析      | AST          | 带标注的 AST      | 类型检查、作用域分析       |
| 中间代码生成  | AST          | 中间代码（IR）    | 生成机器无关表示           |
| 代码优化/生成 | IR           | 目标代码          | 优化、寄存器分配、指令选择 |

------

### 补充说明

- 前端 vs 后端：
  - **前端**（**词法分析→语义分析**）**与语言相关，处理源代码结构。**
  - **后端**（优化→目标代码生成）与机器相关，处理代码执行效率。
- **错误处理**：每个阶段都可能检测到错误（如词法错误、类型不匹配），需及时报告并恢复。
- **现代编译器**：如 GCC、Clang 采用多阶段设计，支持插件化优化和跨平台。

通过这五个阶段，编译器实现了从高级语言到可执行代码的可靠转换。

## 2.各个编译阶段的输入与输出

| 阶段          | 输入         | 输出              | 核心任务                   |
| ------------- | ------------ | ----------------- | -------------------------- |
| 词法分析      | 源代码字符流 | Token 序列        | 分词、去冗余               |
| 语法分析      | Token 序列   | 抽象语法树（AST） | 检查语法结构               |
| 语义分析      | AST          | 带标注的 AST      | 类型检查、作用域分析       |
| 中间代码生成  | AST          | 中间代码（IR）    | 生成机器无关表示           |
| 代码优化/生成 | IR           | 目标代码          | 优化、寄存器分配、指令选择 |

# 计算方法

## l 乔姆斯基文法的分类；

好的！让我们用「做菜」和「学校规则」的生活场景来类比乔姆斯基文法的分类和编译原理中的专业名词，保证通俗易懂！

------

### **1. 乔姆斯基文法的分类**

乔姆斯基将文法分为4类（0~3型），规则约束从宽松到严格：

#### **(0) 无限制文法（Unrestricted Grammar）**

- **专业名词**：短语结构文法（Phrase Structure Grammar）

- 

  通俗解释

  ：像「随意写菜谱」

  - 规则：做菜时没有任何限制，比如“把任意食材变成任意其他食材”（比如“鸡蛋→土豆”）。
  - 场景：像天马行空的黑暗料理，没有逻辑约束，可能做出无法入口的菜。

#### **(1) 上下文有关文法（Context-Sensitive Grammar, CSG）**

- **专业名词**：上下文有关规则（如 `αAβ → αγβ`）

- 

  通俗解释

  ：像「根据场景调整菜谱」

  - 规则：处理食材时，必须看周围环境。比如“只有锅里已经有洋葱时，才能把牛肉切块”（类似 `洋葱 牛肉 洋葱 → 洋葱 牛肉块 洋葱`）。
  - 场景：像严格的烹饪节目，步骤不能乱来，必须符合当前状态。

#### **(2) 上下文无关文法（Context-Free Grammar, CFG）**

- **专业名词**：产生式规则（如 `A → γ`）

- 

  通俗解释

  ：像「固定步骤的速食菜谱」

  - 规则：无论什么情况，遇到食材就按固定步骤处理。比如“见到鸡蛋→打散鸡蛋”（`鸡蛋 → 打散的鸡蛋`），不需要看其他食材。
  - 场景：像泡面说明书，无论饿不饿，操作都一样。编程语言的语法大多属于这类。

#### **(3) 正则文法（Regular Grammar, RG）**

- **专业名词**：有限自动机（Finite Automaton）

- 

  通俗解释

  ：像「流水线加工食材」

  - 规则：只能一步步线性处理，比如“胡萝卜→切丝→炒熟”（`胡萝卜 → 胡萝卜丝 → 熟胡萝卜丝`），不能跳步或嵌套。
  - 场景：像快餐店的流水线，严格按顺序操作，不能中途做其他事。

------

### **2. 编译原理名词的生活映射**

| **专业名词**   | **生活场景比喻**          | 作用                     |
| -------------- | ------------------------- | ------------------------ |
| **终结符**     | 成品菜（如“炒鸡蛋”）      | 最终结果，不可再分解。   |
| **非终结符**   | 半成品（如“打散的鸡蛋”）  | 需要进一步加工。         |
| **产生式规则** | 菜谱步骤（如“鸡蛋→打散”） | 定义如何转换食材。       |
| **推导**       | 按菜谱一步步做菜          | 从原料到成品的转换过程。 |
| **语法分析**   | 检查菜谱步骤是否合法      | 确保程序语法正确。       |

------

### **3. 总结：用学校规则类比**

- **0型**：校长说“随便你们怎么制定班规”（完全自由）。
- **1型**：班主任说“如果教室有老师，学生可以自习”（依赖上下文）。
- **2型**：班长说“所有学生必须交作业”（无视场景，统一规则）。
- **3型**：值日生说“按学号顺序交作业”（严格线性顺序）。

这样是不是更清晰了呢？ 😊

## l 根据文法定义进行推导与规约；

好的！我们结合**抽象语言**（如编程语言、数学表达式）和**生活场景**，用严格的文法术语和通俗类比，重新梳理**推导（Derivation）**与**规约（Reduction）**的核心逻辑。

------

### **1. 抽象语言中的推导与规约**

#### **(1) 推导（Derivation）——生成语言的过程**

- **专业定义**：从文法的开始符号 S 出发，通过**产生式规则**（如 A→α）逐步替换非终结符，最终得到终结符串（句子）。

- 

  抽象语言示例

  （算术表达式文法）：

  ```
  G: 
    E → E + E | E * E | (E) | id  
  推导 "id + id * id" 的步骤：
    E ⇒ E + E          （规则：E → E + E）
      ⇒ id + E         （规则：E → id）
      ⇒ id + E * E     （规则：E → E * E）
      ⇒ id + id * E    （规则：E → id）
      ⇒ id + id * id   （规则：E → id）
  ```

- 

  关键点

  ：

  - 每次替换**一个非终结符**（如第一个 E 被替换为 E+E）。
  - 结果是一个**合法的句子**（属于文法描述的语言）。

#### **(2) 规约（Reduction）——解析语言的过程**

- **专业定义**：从终结符串出发，反向应用产生式规则，将子串替换为非终结符，最终回归到开始符号 S。

- 

  同一文法下的规约

  （对 "id + id * id"）：

  ```
  id + id * id  
    ⇐ id + E * id      （规约：id → E）
    ⇐ id + E * E       （规约：id → E）
    ⇐ id + E           （规约：E * E → E）
    ⇐ E + E            （规约：id → E）
    ⇐ E                （规约：E + E → E）
  ```

- 

  关键点

  ：

  - 每次规约**一个产生式的右部**（如 id 规约为 E）。
  - 用于验证句子是否属于语言，并构建**语法分析树**。

------

### **2. 生活场景的抽象映射**

#### **(1) 推导：编写数学公式**

- 

  场景

  ：老师要求学生按规则生成合法公式。

  - **开始符号**：Expression

  - 

    规则

    ：

    ```
    Expression → Number | Expression + Expression  
    Number → 1 | 2 | 3
    ```

  - 

    推导过程

    ：

    ```
    Expression ⇒ Expression + Expression  
               ⇒ 2 + Expression  
               ⇒ 2 + 3
    ```

  - **结果**：合法公式 "2 + 3"。

#### **(2) 规约：批改数学作业**

- 

  场景

  ：老师检查学生写的公式是否合法。

  - **输入**：公式 "2 + 3"

  - 

    规约过程

    ：

    ```
    2 + 3  
      ⇐ Number + 3       （规约：2 → Number）  
      ⇐ Number + Number  （规约：3 → Number）  
      ⇐ Expression       （规约：Number + Number → Expression）
    ```

  - **结论**：公式合法（可规约到开始符号）。

------

### **3. 编译原理中的核心关联**

| **概念**       | **抽象语言中的角色**             | **生活类比**                   | 编译阶段               |
| -------------- | -------------------------------- | ------------------------------ | ---------------------- |
| **产生式规则** | 语言的生成/解析规则              | 数学公式的书写规则             | 语法分析的基础         |
| **推导**       | 生成合法句子（编译器设计阶段）   | 按规则写出公式                 | 自顶向下分析（LL文法） |
| **规约**       | 验证句子合法性（编译器运行阶段） | 检查公式是否符合规则           | 自底向上分析（LR文法） |
| **非终结符**   | 中间抽象符号（如 E）             | 未完成的公式部分（如 "□ + 3"） | 语法树的中间节点       |
| **终结符**     | 语言的最小单位（如 id）          | 公式中的数字/运算符            | 词法分析后的单词       |

------

### **4. 为什么需要抽象语言视角？**

1. 

   精确性

   ：形式化文法（如CFG）是编程语言语法的基础，推导与规约对应语法分析的核心操作。

   - 例：编译器解析 `a = b + c;` 时，需规约为 `赋值语句 → 标识符 = 表达式`。

2. **通用性**：所有上下文无关语言（如JSON、SQL）均可用此框架分析。

3. **自动化**：推导与规约的步骤可转化为算法（如递归下降、移进-归约）。

------

### **5. 更复杂的例子：嵌套结构的推导与规约**

**文法**（简化版if语句）：

```
S → if (E) S | other  
E → id | num
```

**句子**：`if (x) if (y) other`

- 

  推导

  ：

  ```
  S ⇒ if (E) S  
     ⇒ if (x) S                （E → x）  
     ⇒ if (x) if (E) S         （S → if (E) S）  
     ⇒ if (x) if (y) other     （E → y, S → other）
  ```

- 

  规约

  ：

  ```
  if (x) if (y) other  
    ⇐ if (x) if (y) S          （other → S）  
    ⇐ if (x) S                 （if (y) S → S）  
    ⇐ S                        （if (x) S → S）
  ```

**生活类比**：

- 推导：像写嵌套的“如果...那么...”规则。
- 规约：像解套娃，从最内层的 `other` 逐步确认整体是一个合法语句。

------

### **总结**

- **推导**是“生成”，规约是“解析”，二者互为逆过程。
- 在抽象语言中，它们形式化地定义了**语言的合法性**和**语法结构**。
- 编译器中，推导对应语法设计，规约对应语法分析，是代码→语法树的关键步骤。

如果需要用具体编程语言（如Python或C）的语法举例，可以进一步展开！

## l 正则表达式

### n 正则表达式到NFA的转换

- +表示一个或者多个。对于（a|b）+ 可以转化为(a|b)(a|b)*
- 看到*，将星号修饰的内容自环于某一个状态点，并且该状态点和其他状态点之间用厄普西隆连接
- 对于ab 则串联状态节点
- 对于a|b 则并联状态节点-若此时的a|b是某个*的自环节点，则画两条自环的箭头

![image-20250518200033366](./assets/image-20250518200033366.png)

![image-20250518200023653](./assets/image-20250518200023653.png)

### n 使用子集构造法将NFA转DFA

- I的第一个集合，是从X开始的
- Ia和Ib指的是，I中的元素施加a/b可以走到的位置
- 你会发现，只有第一个集合有X 是因为X只能走伊普西龙，无法和a和b发生任何作用
- 遇到伊普西龙就可以往右边走，无条件的走，并且将走到的结果添加到当前集合。
- 施加a或者b的只能是I中的集合，你别拿到从1 2 4 出发拿到3了，就觉得可以从3到5，不可以的，你只能对I中的集合施加A或者B。这里的5是你通过I集合施加a或者b得到的结果（不能贪杯）
- 这里编号的意思是：对不一样的集合做一个序号，然后等会咱们拿序号来构建DFA

![image-20250518202832304](./assets/image-20250518202832304.png)

![image-20250518202843891](./assets/image-20250518202843891.png)

![image-20250518203143962](./assets/image-20250518203143962.png)

![image-20250518203130385](./assets/image-20250518203130385.png)

![image-20250518203301034](./assets/image-20250518203301034.png)

- 先做划分：上面有Y的就是终态集合。其他是是非终态集合

### n DFA最小化

## l LL分析法

### n First集和Follow集的计算

### n LL(1)分析表的计算

### n LL(1)文法的判别

### n 消除左递归，提取公共左子因子

## l LR分析法

### n LR(0)自动机的计算

### n LR、SLR、LALR文法的判别与证明

## l 中间代码表示

### n 中缀表达式、后缀表达式、三元式、四元式间的互相转换

## l 优化技术

### n 消除公共表达式、复写传播、消除无用表达式等

 

## 掌握各种技术的使用场景与优劣

### l 符号表实现方式的选择与比较

### l 词法分析技术的选择与比较

### l 语法分析技术的选择与比较

### l 中间语言的选择与比较

### l 内存管理技术的选择与比较

### l 编译功能变化时，需要修改编译程序的哪个部分

### 