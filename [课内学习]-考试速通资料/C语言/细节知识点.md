## 1.结构体可以在;前用数组初始化

```c
#include<stdio.h>
struct S{
    int a;
    int b;
}data[2]={10,100,20,200};
int main(){
    struct S p = data[1];
    printf("%d\n",++(p.a));
}
```

## 2.结构体指针不能用.得用->

```c
#include<stdio.h>
struct book{
    float price;
    char language;
    char title[20];
}rec,*ptr;

int main(){
    ptr = &rec;
    scanf("%s",ptr->title);
    printf("%s",ptr->title);
}
```

## 3.只有被typedef后的名字才能不带struct直接用

```c
#include<stdio.h>
typedef struct data{
    int x;
    int y;
}data2;
struct data0{
    int x;
    int y;
}
typedef struct {
    float x;
    float y;
}data3;

int main(){
    struct data0 = {1,2};//但是没有typedef 你就得用struct来定义
    data2 d2 = {1,2};//data2和data3是在typedef的}后定义的，因此可以直接用这个+括号来声明，但是
    data3  d3 = {2,3};
    printf("%d %d\n%f %f",d2.x,d2.y,d3.x,d3.y);
}
```

## 4.结构体数组式声明的计算

```c
#include<stdio.h>

struct cm{
    int x;
    int y;

}a[2]={4,3,2,1};

int main(){
    printf("%d\n",a[0].y/a[0].x*a[1].x);
}
//这一块的结果为0
```

## 5.文件写入相关API

> 该程序示例涉及到文件写入操作，并使用了标准C库中的多个文件操作API，包括`fopen`、`fwrite`、`fseek`、`fread`、`fclose`。下面对程序中的每个部分进行详细分析，尤其是文件写入相关的API及其参数。
>
> ### 代码分析
>
> ```c
> #include<stdio.h>
> 
> int main(){
>     FILE  *fp;
>     int i;
>     int a[6] = {1, 2, 3, 4, 5, 6};  // 初始化一个包含6个整数的数组
>     int k;
> 
>     fp = fopen("data.dat", "w+b");  // 打开文件"data.dat"，以读写二进制模式打开（写入二进制）
>     fwrite(&a[0], sizeof(int), 1, fp);  // 将数组a的第一个元素写入文件
> 
>     // 逐个写入数组的其他元素
>     for(int i = 1; i < 6; i++){
>         fseek(fp, 0L, 0);  // 将文件指针移动到文件开头
>         fwrite(&a[i], sizeof(int), 1, fp);  // 将数组第i个元素写入文件
>     }
> 
>     fseek(fp, 0L, 0);  // 将文件指针移到文件开头
>     fread(&k, sizeof(int), 1, fp);  // 从文件中读取一个整数并存入变量k
>     fclose(fp);  // 关闭文件
> 
>     printf("%d", k);  // 打印读取到的整数
> }
> ```
>
> ### 关键API分析
>
> 1. **`fopen`**: 打开文件
>
>     ```c
>     fp = fopen("data.dat", "w+b");
>     ```
>     - **`fopen`**：用于打开文件。该函数返回一个`FILE *`类型的指针，指向打开的文件。
>     - 参数：
>         - `"data.dat"`：文件名，指示要操作的文件。
>         - `"w+b"`：文件打开模式，表示以读写二进制模式打开。如果文件不存在，会创建一个新文件；如果文件存在，则会清空文件内容。
>
> 2. **`fwrite`**: 写入数据到文件
>
>     ```c
>     fwrite(&a[0], sizeof(int), 1, fp);
>     ```
>     - **`fwrite`**：用于将数据写入到文件中。
>     - 参数：
>         - `&a[0]`：指向要写入数据的地址，这里是数组`a`的第一个元素的地址。
>         - `sizeof(int)`：每次写入的数据块的大小，这里是`int`类型的大小，通常是4字节（具体依赖于系统架构）。
>         - `1`：要写入的块数，这里是写入1个`int`类型的数据。
>         - `fp`：文件指针，指定要写入的文件。
>
> 3. **`fseek`**: 移动文件指针
>
>     ```c
>     fseek(fp, 0L, 0);
>     ```
>     - **`fseek`**：用于设置文件指针的位置。
>     - 参数：
>         - `0L`：偏移量，这里是0，表示文件指针移动到文件的开头。
>         - `0`：起始位置标志，表示从文件的开头开始计算偏移量（`SEEK_SET`），文件指针会被设置到文件的开始位置。
>
> 4. **`fread`**: 从文件读取数据
>
>     ```c
>     fread(&k, sizeof(int), 1, fp);
>     ```
>     - **`fread`**：用于从文件中读取数据。
>     - 参数：
>         - `&k`：读取的数据存储地址，这里是变量`k`的地址。
>         - `sizeof(int)`：每次读取的数据块大小，这里是`int`类型的大小，通常是4字节。
>         - `1`：要读取的块数，这里是读取1个`int`类型的数据。
>         - `fp`：文件指针，指定从哪个文件读取数据。
>
> 5. **`fclose`**: 关闭文件
>
>     ```c
>     fclose(fp);
>     ```
>     - **`fclose`**：关闭文件，释放文件指针关联的资源。
>
> ### 代码中的潜在问题
>
> 1. **`fseek`和`fwrite`的使用方式**：
>    - 在循环中，`fseek(fp, 0L, 0)`每次都会将文件指针移到文件开头。这会导致每次写入时都覆盖掉之前写入的数据。由于文件指针始终回到文件开头，因此每次`fwrite`都会覆盖文件中的内容，而不是在文件末尾追加数据。
>    - 如果程序的目的是依次将数组`a`的所有元素写入文件，并且不想覆盖先前的数据，应该避免每次都调用`fseek`将文件指针移到文件开头。可以通过调整`fseek`的使用或使用`fwrite`时不调用`fseek`来实现按顺序写入数据。
>
> 2. **文件操作模式选择**：
>    - 打开文件时使用的是`"w+b"`模式，即以二进制模式读写文件。如果目标文件已经存在，`"w+"`模式会清空文件内容，`"b"`则保证数据以二进制格式读写。该模式适用于处理二进制数据，而如果处理文本数据，通常会使用`"w"`或`"r"`模式。
>
> 3. **`fseek`的位置**：
>    - `fseek(fp, 0L, 0)`将文件指针移到文件开头，虽然可以成功读取第一个整数，但若文件中已经有多个整数时，`fseek`可能导致不正确的数据读取。在这个例子中，使用`fseek`后，`fread`能正确读取文件开头的第一个整数，但是它并未体现出对文件内容的顺序写入和读取。
>
> ### 期望的行为与改进建议
>
> 若程序的目的是将数组`a`的所有元素按顺序写入文件，并在之后读取文件中的第一个整数，代码应进行如下修改：
>
> 1. 移除`fseek`调用，避免每次覆盖文件内容。
> 2. 确保`fwrite`能够按顺序写入数组的元素，而不是覆盖。
>
> 修改后的代码如下：
>
> ```c
> #include<stdio.h>
> 
> int main(){
>     FILE  *fp;
>     int i;
>     int a[6] = {1, 2, 3, 4, 5, 6};
>     int k;
> 
>     fp = fopen("data.dat", "w+b");  // 打开文件
>     for(int i = 0; i < 6; i++){
>         fwrite(&a[i], sizeof(int), 1, fp);  // 按顺序写入每个元素
>     }
> 
>     fseek(fp, 0L, SEEK_SET);  // 移动文件指针到开头
>     fread(&k, sizeof(int), 1, fp);  // 读取第一个元素
>     fclose(fp);  // 关闭文件
> 
>     printf("%d", k);  // 打印读取到的整数
> }
> ```
>
> ### 总结
>
> - **`fwrite`**和**`fread`**都是进行二进制数据读写的函数，前者用于写入数据，后者用于读取数据。
> - **`fseek`**用于改变文件指针的位置，配合其他文件操作函数（如`fread`、`fwrite`）来控制数据的读写位置。
> - 在循环中重复调用`fseek(fp, 0L, 0)`会导致每次写入都覆盖文件中的内容，这应当避免。

## 6.EOF只能作为文本结束标志

EOF的本质是一个#defiine的宏，一般值为-1。以EOF结尾的文件一定是文本文件。

## 7.fclose()一定要关闭文件

## 8.fread参数详解

```c
fread(buffer,size,count,fp);
//1.buffer是一个内存块的首地址，比如&arr[0]
//2.size是每次读取元素要读size个字节,我们一般用sizeof(int)
//3.count是指从文件流中最多读取count个元素进入buffer指向的内存中
//4.fp是指从哪个文件读取,这是一个文件指针
```

## 9.fgets的细节参数：(字符串/读取字符数量-1[因为包含\0]/输入流文件指针)

```c
#include <stdio.h>
int main() {
    FILE *fp = fopen("example.txt", "r");  // 打开文件
    if (fp == NULL) {
        printf("Failed to open file.\n");
        return 1;
    }

    char str[100];  // 用于存储读取的行
    while (fgets(str, 100, fp)) {
        //1.首先是一个缓存的字符串
        //2.其次是要读取的最大字符数,这个字符是包含\0的 所以如果fgets(str,n,fp)的话,实际只能读取n-1个数
        //3.fp是指定输入流，这里是文件指针
        printf("Read line: %s", str);  // 打印读取的每一行
    }

    fclose(fp);  // 关闭文件
    return 0;
}

```

## 10.文件的严格访问权限："W"和"w+b"fopen的文件,是不可以从中读取文件的

## 11.feof函数(只关心文件是否走到末尾,但不关心是否出现错误)

## 12.%d只能输出十进制,八进制需转化

```java
int x = 012;
printf("%s,X=%d.\n",msg,x+1);
//012转成十进制是10 然后10+1=11
```

## 13.字符串+数字是位移

```java
char b[] = "happynewyear";
printf("%s%s","12345678"+4,b+8);
//切记索引是从0开始的 +4是从0移动4到4 b+8也是从0开始移动到8
//字符串+4的意思是：从字符串的零索引开始+4，然后加后的索引开始到最后的元素都作为结果

```

## 14.字符串比较相等 使用strcmp(a,b)==0

```java
if(strcmp(a,b)==0){}
//在c语言中,不可以使用==号
```

## 15.十六进制转译：'\x6D'可以，'\0x6d'不行。同时八进制是'\057

## 16.常见转义字符

序号	转义字符	转义功能	ASCII码值
1	\0	空字符	0
2	\a	响铃	7
3	\b	退格（Backspace）	8
4	\t	水平制表符（即横向跳格）	9
5	\n	回车换行（Enter）	10
6	\v	竖向跳格	11
7	\f	换页	12
8	\r	回车	13
9	\"	双引号（"）	34
10	\’	单引号（‘’）	39
11	\?	问号（?）	63
12	\\	反斜线字符（\）	92
13	\ddd	1~3位八进制所代表的字符	
14	\xhh	1~2位十六进制所代表的字符	
