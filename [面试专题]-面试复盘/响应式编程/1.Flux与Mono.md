# Reactor框架核心概念详解：为初学者与面试准备

Reactor是Java生态中实现响应式编程的核心框架，广泛应用于Spring WebFlux等高并发场景。本文面向初学者，深入浅出地讲解Reactor框架的核心概念，包括**Mono/Flux的创建与操作符**（map/flatMap/filter）、**线程调度模型（Schedulers）与上下文传播**、**错误处理与重试机制**。同时，我们将澄清Reactor框架与Netty的Reactor Handler模型的区别，并为面试准备常见问题、详细解析和代码示例，助你在技术面试中游刃有余。

------

## 一、什么是Reactor框架？

Reactor是基于Reactive Streams规范的Java响应式编程库，核心类型是**Flux**（发出0到多个数据项）和**Mono**（发出0或1个数据项），用于处理异步数据流。它通过声明式编程、背压支持和丰富的操作符，构建高效、异步、非阻塞的应用程序。

**类比**：想象Reactor是一条智能流水线，数据（货物）在流水线（Flux/Mono）上流动，工人（操作符）对货物进行加工，调度员（Schedulers）决定在哪个工作站（线程）处理，错误处理机制则确保流水线在故障时不崩溃。

### Reactor与Netty Reactor Handler的区别

**问题澄清**：Reactor框架（Project Reactor）与Netty的Reactor Handler模型是完全不同的概念，尽管都涉及异步和事件驱动。

- **Project Reactor**：一个响应式编程库，专注于处理异步数据流，基于Reactive Streams规范，提供Flux/Mono等类型，广泛用于Spring WebFlux等场景。它关注**数据流处理**，如转换、过滤和错误处理。

- **Netty Reactor Handler**：Netty是一个异步网络框架，其Reactor模型是一种基于事件循环的I/O处理模式，使用EventLoop和ChannelHandler处理网络事件（如连接、读写）。它关注**网络I/O**，而非数据流处理。

- 关键区别

  ：

  - **应用场景**：Project Reactor用于通用响应式编程（如Web、流处理）；Netty的Reactor模型用于高性能网络通信（如服务器开发）。
  - **核心组件**：Project Reactor使用Flux/Mono，Netty使用EventLoop和Channel。
  - **编程范式**：Project Reactor是声明式数据流处理，Netty是命令式的事件处理。

**类比**：Project Reactor像一个物流中心，处理包裹的加工和分发；Netty的Reactor Handler像一个港口，管理船只（网络连接）的进出。

------

## 二、Reactor框架核心概念

### 1. Mono/Flux的创建与操作符（map/flatMap/filter）

#### 概念讲解

- **Flux**：表示0到多个数据项的异步序列，适合处理列表、日志流等。

- **Mono**：表示0或1个数据项的异步序列，适合单次操作，如HTTP请求响应。

- 操作符

  ：用于转换、过滤或组合数据流，类似流水线上的加工步骤。

  - **map**：对每个数据项进行同步转换（1:1映射）。
  - **flatMap**：将每个数据项转换为一个新的Flux/Mono（1:N映射，支持异步）。
  - **filter**：筛选符合条件的数据项。

**类比**：Flux像一条河流，承载多个鱼（数据）；Mono像一个快递包裹，只有一个或没有货物。操作符是工人，对鱼或包裹进行加工（map）、拆分（flatMap）或挑选（filter）。

#### 代码示例

以下展示Mono/Flux的创建和操作符使用：

```java
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

public class MonoFluxDemo {
    public static void main(String[] args) {
        // 创建Flux
        Flux<String> fruits = Flux.just("apple", "banana", "orange");
        
        // 使用map转换为大写
        fruits.map(String::toUpperCase)
              .subscribe(System.out::println); // 输出：APPLE, BANANA, ORANGE
        
        // 使用filter筛选以'a'开头的水果
        fruits.filter(fruit -> fruit.startsWith("a"))
              .subscribe(System.out::println); // 输出：apple
        
        // 使用flatMap将每个水果拆分为字符流
        fruits.flatMap(fruit -> Flux.fromArray(fruit.split("")))
              .subscribe(System.out::println); // 输出：a, p, p, l, e, b, a, n, a, n, a, o, r, a, n, g, e
        
        // 创建Mono
        Mono<String> singleFruit = Mono.just("apple");
        singleFruit.map(String::toUpperCase)
                   .subscribe(System.out::println); // 输出：APPLE
    }
}
```

#### 面试问题及解析

**问题**：map和flatMap的区别是什么？
**答案**：

- **map**：同步转换每个元素，生成1:1的映射。例如，将字符串转为大写。

- **flatMap**：将每个元素映射为一个新的Flux/Mono（异步流），然后展平结果，适合嵌套流处理。

- 解析

  ：

  - map：`Flux<String> -> Flux<String>`（转换后仍是同类型流）。
  - flatMap：`Flux<String> -> Flux<Flux<T>> -> Flux<T>`（展平嵌套流）。

- 示例：

```java
Flux.just("apple", "banana")
    .flatMap(fruit -> Mono.just(fruit.toUpperCase())) // 异步转换
    .subscribe(System.out::println);
```

**问题**：如何选择Flux还是Mono？
**答案**：

- 使用Flux处理多条数据（如列表、流）；使用Mono处理单个数据或无数据（如HTTP响应）。
- **解析**：Mono适合明确知道结果是单一的场景，Flux适合动态或未知数量的场景。

------

### 2. 线程调度模型（Schedulers）与上下文传播

#### 概念讲解

- Schedulers

  ：Reactor的线程调度器，决定数据流在哪个线程执行。常见调度器：

  - `Schedulers.parallel()`：用于CPU密集型任务，线程数与CPU核心数相关。
  - `Schedulers.boundedElastic()`：用于I/O密集型任务（如数据库、网络操作）。
  - `Schedulers.single()`：单一线程，适合简单任务。
  - `Schedulers.immediate()`：当前线程执行。

- **上下文传播**：Reactor的`Context`机制允许在数据流中传递元数据（如用户ID），在异步操作中保持上下文一致。

**类比**：Schedulers像工厂的调度员，决定任务在哪个工作站（线程）执行；上下文传播像在包裹上贴标签，确保物流过程中信息不丢失。

#### 代码示例

展示Schedulers和上下文传播：

```java
import reactor.core.publisher.Mono;
import reactor.core.scheduler.Schedulers;
import reactor.util.context.Context;

public class SchedulerContextDemo {
    public static void main(String[] args) throws InterruptedException {
        // 使用Schedulers切换线程
        Mono.just("Hello")
            .map(s -> s + " World")
            .publishOn(Schedulers.parallel()) // 切换到并行线程
            .doOnNext(s -> System.out.println("线程: " + Thread.currentThread().getName()))
            .subscribeOn(Schedulers.boundedElastic()) // 订阅线程
            .subscribe(System.out::println);
        
        // 上下文传播
        Mono.deferContextual(ctx -> 
            Mono.just("User: " + ctx.get("userId")))
            .contextWrite(Context.of("userId", "Alice"))
            .subscribe(System.out::println); // 输出：User: Alice
        
        Thread.sleep(1000); // 等待异步完成
    }
}
```

**运行结果**：

```
线程: parallel-1
Hello World
User: Alice
```

#### 面试问题及解析

**问题**：publishOn和subscribeOn的区别？
**答案**：

- **publishOn**：影响操作符链中后续操作的执行线程。

- **subscribeOn**：影响整个数据流的订阅线程（从数据源开始）。

- 解析

  ：

  - `publishOn`改变下游操作的线程，适合分段调度。
  - `subscribeOn`影响整个流的线程，适合控制数据源的线程。

- 示例：

```java
Mono.just("Test")
    .subscribeOn(Schedulers.boundedElastic())
    .map(s -> s.toUpperCase())
    .publishOn(Schedulers.parallel())
    .subscribe();
```

**问题**：上下文传播的典型用途？
**答案**：

- 用于传递请求级信息，如用户ID、认证令牌或跟踪ID，特别是在WebFlux中。
- **解析**：Context确保异步操作中元数据不丢失，适合分布式追踪或日志记录。

------

### 3. 错误处理与重试机制

#### 概念讲解

Reactor提供丰富的错误处理机制，确保系统健壮性：

- 错误处理操作符

  ：

  - `onErrorReturn`：错误时返回默认值。
  - `onErrorResume`：错误时切换到备用流。
  - `onErrorMap`：转换错误类型。

- 重试机制

  ：

  - `retry(n)`：重试指定次数。
  - `retryWhen`：自定义重试策略（如延迟重试）。

**类比**：错误处理像流水线上的质检员，发现次品（错误）后替换或修复；重试像重新加工次品，尝试修复问题。

#### 代码示例

展示错误处理和重试：

```java
import reactor.core.publisher.Flux;
import reactor.util.retry.Retry;
import java.time.Duration;

public class ErrorHandlingDemo {
    public static void main(String[] args) {
        // 错误处理
        Flux.just(1, 2, 0, 4)
            .map(i -> 10 / i) // 除以0抛出异常
            .onErrorReturn(-1) // 错误时返回-1
            .subscribe(System.out::println);
        
        // 重试机制
        Flux.just(1, 2, 0, 4)
            .map(i -> 10 / i)
            .retry(2) // 重试2次
            .onErrorReturn(-2)
            .subscribe(System.out::println);
        
        // 自定义重试
        Flux.just(1, 2, 0)
            .map(i -> 10 / i)
            .retryWhen(Retry.fixedDelay(3, Duration.ofSeconds(1))) // 3次重试，每次间隔1秒
            .onErrorReturn(-3)
            .subscribe(System.out::println);
    }
}
```

**运行结果**：

```
10
5
-1
10
5
-2
10
5
-3
```

#### 面试问题及解析

**问题**：如何选择onErrorReturn和onErrorResume？
**答案**：

- **onErrorReturn**：返回固定默认值，适合简单场景。

- **onErrorResume**：返回备用数据流，适合复杂逻辑（如查询备用数据库）。

- 解析

  ：

  - `onErrorReturn`简单但灵活性低。
  - `onErrorResume`支持动态生成数据流。

- 示例：

```java
Flux.error(new RuntimeException("Error"))
    .onErrorResume(e -> Flux.just("Backup"))
    .subscribe(System.out::println); // 输出：Backup
```

**问题**：retry和retryWhen的区别？
**答案**：

- **retry(n)**：简单重试指定次数。
- **retryWhen**：支持自定义重试策略，如延迟或条件重试。
- **解析**：`retryWhen`更灵活，适合网络请求等场景。

------

## 三、Reactor与Netty Reactor Handler的对比（补充）

为澄清问题，以下进一步对比：

| **特性**     | **Project Reactor**           | **Netty Reactor Handler**    |
| ------------ | ----------------------------- | ---------------------------- |
| **用途**     | 响应式数据流处理              | 异步网络I/O处理              |
| **核心组件** | Flux/Mono，操作符，Schedulers | EventLoop，Channel，Handler  |
| **编程范式** | 声明式（操作符链）            | 命令式（事件处理）           |
| **典型场景** | WebFlux、流处理、微服务       | 网络服务器、客户端、协议实现 |
| **背压支持** | 原生支持（Reactive Streams）  | 通过自定义Handler间接实现    |

**面试问题**：Reactor和Netty的Reactor模型可以结合使用吗？
**答案**：

- 可以，Spring WebFlux内部使用Netty作为默认网络引擎，Netty处理底层I/O，Reactor处理上层数据流。
- **解析**：Netty负责高效的网络通信，Reactor负责业务逻辑的响应式处理，两者互补。

------

## 四、面试准备：更多问题与答案

**问题1**：如何调试Reactor代码？
**答案**：

- 使用`log()`操作符记录数据流事件，或`doOnNext`、`doOnError`添加日志。
- 示例：

```java
Flux.just(1, 2, 3)
    .log() // 记录所有事件
    .map(i -> i * 2)
    .subscribe(System.out::println);
```

- **解析**：`log()`输出数据流生命周期事件，便于调试。

**问题2**：Schedulers.parallel()和boundedElastic()的适用场景？
**答案**：

- **parallel()**：CPU密集型任务，如计算密集型处理。
- **boundedElastic()**：I/O密集型任务，如数据库查询、网络请求。
- **解析**：选择合适的Schedulers避免线程资源浪费。

**问题3**：如何在WebFlux中处理响应式数据库操作？
**答案**：

- 使用R2DBC或Spring Data Reactive，结合Mono/Flux操作数据库。
- 示例：

```java
@Repository
public interface UserRepository extends ReactiveCrudRepository<User, Long> {
    Flux<User> findByName(String name);
}
```

- **解析**：R2DBC支持非阻塞数据库操作，与Reactor无缝集成。

**问题4**：如何避免Reactor中的内存泄漏？
**答案**：

- 使用`Disposable`取消订阅，及时释放资源。
- 示例：

```java
Disposable disposable = Flux.interval(Duration.ofSeconds(1))
    .subscribe(System.out::println);
disposable.dispose(); // 取消订阅
```

- **解析**：在无限流或长期运行的订阅中，取消订阅至关重要。

------

## 五、总结

Reactor框架通过Flux/Mono、操作符、Schedulers和错误处理机制，构建高效的响应式应用程序。与Netty的Reactor Handler模型相比，Project Reactor专注于数据流处理，而Netty专注于网络I/O，两者可结合使用。掌握核心概念、代码示例和面试问题解析，能帮助你轻松应对响应式编程相关的面试挑战。希望本文为你提供清晰的指导和实践支持！