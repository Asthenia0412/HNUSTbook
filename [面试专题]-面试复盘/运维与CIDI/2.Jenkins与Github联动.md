# 基于 Git Flow 的 Jenkins CI/CD 流程与双周迭代详解

本文基于 Git Flow 开发流程，详细讲解 FAT、UAT 和生产环境（PRO）从哪些分支拉取代码、如何发版，并以一个双周迭代的项目为例，说明普通程序员和项目 Leader 的职责。结合 Jenkins 的 SCM 轮询、Webhooks、私有仓库访问、Pipeline 配置和完整链路，深入分析 CI/CD 流程的每个细节。

## 一、Git Flow 开发流程概述

Git Flow 是一种广泛使用的分支管理策略，适合需要严格版本控制的项目。其核心分支包括：

- **main**：主分支，始终保持生产环境的稳定代码。
- **develop**：开发分支，集成所有开发完成的特性，反映下一版本的状态。
- **feature/**：特性分支，从 `develop` 分支创建，用于开发新功能，完成后合并回 `develop`。
- **release/**：发布分支，从 `develop` 分支创建，用于准备发布，完成后合并到 `main` 和 `develop`。
- **hotfix/**：热修复分支，从 `main` 分支创建，用于修复生产环境问题，完成后合并到 `main` 和 `develop`。

### 1.1 环境与分支对应关系

基于 Git Flow，三个环境的代码来源如下：

- **FAT（功能验收测试）**：从 `develop` 分支拉取，测试最新开发的功能。
- **UAT（用户验收测试）**：从 `release/*` 分支拉取，测试即将发布的版本。
- **PRO（生产环境）**：从 `main` 分支拉取，部署经过验证的稳定代码。

### 1.2 发版流程

发版流程基于 Git Flow 的 `release/*` 分支：

1. 创建发布分支

   ：

   - 从 `develop` 创建 `release/vX.Y.Z`（例如 `release/v1.0.0`）。
   - 进行小规模修复、版本号更新、文档完善。

2. UAT 环境测试

   ：

   - 部署 `release/vX.Y.Z` 到 UAT 环境。
   - 完成用户验收测试，修复发现的问题。

3. 合并到 main 和 develop

   ：

   - 测试通过后，将 `release/vX.Y.Z` 合并到 `main`（用于生产部署）。
   - 同时合并回 `develop`，同步修复内容。

4. 生产部署

   ：

   - 从 `main` 拉取代码，部署到生产环境。

5. 打 Tag

   ：

   - 在 `main` 上为发布版本打 Tag（如 `v1.0.0`），便于追溯。

6. Hotfix 处理

   ：

   - 若生产环境发现问题，从 `main` 创建 `hotfix/vX.Y.Z` 分支。
   - 修复后合并到 `main` 和 `develop`，重新部署。

## 二、双周迭代流程：普通程序员与项目 Leader 的职责

假设项目是一个 Java Spring Boot 应用，采用双周迭代（Sprint），以下是普通程序员和项目 Leader 的工作内容。

### 2.1 普通程序员的工作

- 第 1 周：开发与单元测试
  - **创建特性分支**：从 `develop` 创建 `feature/task-123` 分支，开发新功能（如用户登录模块）。
  - **编写代码**：实现功能，提交代码到私有 GitHub 仓库。
  - **单元测试**：编写 JUnit 测试用例，使用 `mvn test` 验证。
  - **提交 Pull Request**：开发完成后，提交 PR 到 `develop`，等待代码审查。
  - **触发 FAT 部署**：PR 合并到 `develop` 后，Jenkins 自动触发 FAT 环境部署，验证功能。
- 第 2 周：测试与修复
  - **FAT 环境测试**：在 FAT 环境验证功能，修复 Bug。
  - **参与代码审查**：审查其他程序员的 PR，确保代码质量。
  - **准备发布**：协助完善 `release/vX.Y.Z` 分支的文档或小修补。

### 2.2 项目 Leader 的工作

- 第 1 周：规划与协调
  - **迭代规划**：组织 Sprint 计划会，分配任务（如 `feature/task-123`）。
  - **配置 Jenkins**：确保 Jenkins Pipeline 针对 `develop` 和 `release/*` 分支正确配置。
  - **代码审查**：审核程序员提交的 PR，确保符合规范。
  - **监控 FAT 部署**：检查 Jenkins 构建日志，验证 FAT 环境部署结果。
- 第 2 周：发布与管理
  - **创建发布分支**：从 `develop` 创建 `release/vX.Y.Z`，更新版本号。
  - **协调 UAT 测试**：与 QA 团队协作，部署到 UAT 环境，跟踪测试反馈。
  - **批准生产部署**：审核 UAT 测试结果，批准 `release/vX.Y.Z` 合并到 `main`。
  - **监控生产部署**：通过 Jenkins 部署到生产环境，检查日志和监控告警。
  - **版本管理**：在 `main` 上打 Tag，归档版本。

## 三、Jenkins 与 GitHub 联动的过程分析

Jenkins 通过 SCM 轮询或 GitHub Webhooks 与 GitHub 联动，实现自动化构建、测试和部署。

### 3.1 SCM 轮询机制及 Cron 表达式详解

SCM 轮询是 Jenkins 的传统方式，适合网络隔离场景。

#### 3.1.1 SCM 轮询工作原理

- 配置

  ：

  - 在 Jenkins 任务中配置 Git 仓库地址。
  - 启用“Poll SCM”，设置 Cron 表达式。

- 工作原理

  ：

  - Jenkins 定期查询仓库的 HEAD 提交记录。
  - 检测到新提交后触发 Pipeline。

- 优缺点

  ：

  - **优点**：无需 GitHub 端配置。
  - **缺点**：高频率轮询增加负载，低频率导致延迟。

#### 3.1.2 Cron 表达式详解

Cron 表达式定义轮询调度，格式为 `分钟 小时 日期 月份 星期`：

- 语法

  ：

  - 可使用数字、范围（`1-5`）、列表（`1,3,5`）、`*`（任意值）、`H`（随机值）。
  - 示例：
    - `* * * * *`：每分钟轮询。
    - `H/5 * * * *`：每 5 分钟随机轮询。
    - `0 2 * * 1-5`：周一到周五凌晨 2 点轮询。
    - `H H * * *`：每天随机时间轮询。
    - `H(0-29)/5 * * * *`：每小时前 30 分钟，每 5 分钟随机轮询。

- **H 符号**：随机值，避免任务冲突。例如，`H/5 * * * *` 可能在第 2 或 4 分钟触发。

- 配置建议

  ：

  - FAT 环境（`develop` 分支）：`H/5 * * * *`，快速检测新功能。
  - UAT 环境（`release/*` 分支）：`H/15 * * * *`，减少轮询频率。
  - 生产环境（`main` 分支）：`H H * * *`，降低负载。

- 注意

  ：

  - 确保 Jenkins 有仓库权限。
  - 注意 GitHub API 配额。

### 3.2 GitHub Webhooks 机制

Webhooks 是事件驱动方式，适合实时触发：

1. 配置 GitHub Webhook

   ：

   - 在 GitHub 仓库 `Settings -> Webhooks` 添加 Webhook。
   - URL：`http://<Jenkins_URL>/github-webhook/`。
   - 事件：`push`、`pull request`。

2. Jenkins 配置

   ：

   - 安装 `GitHub Integration Plugin`。
   - 启用 `GitHub hook trigger for GITScm polling`。

3. 工作原理

   ：

   - GitHub 在事件发生时发送 POST 请求。
   - Jenkins 验证并触发构建。

4. 优缺点

   ：

   - **优点**：实时性高，资源占用低。
   - **缺点**：Jenkins 需可被 GitHub 访问。

## 四、Jenkins 部署细节

### 4.1 安装 Jenkins

1. 环境准备

   ：

   - 操作系统：Ubuntu。

   - 安装 OpenJDK 11：

     ```bash
     sudo apt update
     sudo apt install openjdk-11-jdk
     ```

2. 安装 Jenkins

   ：

   - 添加仓库并安装：

     ```bash
     wget -q -O - https://pkg.jenkins.io/debian/jenkins.io.key | sudo apt-key add -
     sudo sh -c 'echo deb http://pkg.jenkins.io/debian-stable binary/ > /etc/apt/sources.list.d/jenkins.list'
     sudo apt update
     sudo apt install jenkins
     ```

   - 启动 Jenkins：

     ```bash
     sudo systemctl start jenkins
     sudo systemctl enable jenkins
     ```

3. 访问 Jenkins

   ：

   - 访问 `http://<服务器IP>:8080`。
   - 使用初始密码（`/var/lib/jenkins/secrets/initialAdminPassword`）。

### 4.2 配置 Jenkins

1. 安装插件

   ：

   - 推荐：`GitHub Integration Plugin`、`Docker Pipeline Plugin`、`Pipeline Plugin`、`Kubernetes Plugin`。

2. 全局配置

   ：

   - 配置 JDK、Maven、Docker、kubectl 路径。
   - 设置 GitHub OAuth 或 LDAP。

3. 网络配置

   ：

   - 开放 8080 端口或配置 Nginx 反向代理。

### 4.3 优化 Jenkins

- 性能

  ：

  - 增加 JVM 内存：

    ```bash
    JAVA_ARGS="-Xmx2048m"
    ```

  - 配置从节点。

- 安全

  ：

  - 启用 CSRF 保护。
  - 限制防火墙端口。

## 五、访问私有仓库：SSH vs PAT

### 5.1 使用 SSH 访问

1. 生成 SSH 密钥

   ：

   - 在 Jenkins 服务器：

     ```bash
     ssh-keygen -t rsa -b 4096 -C "jenkins@example.com"
     ```

   - 将公钥添加到 GitHub `Settings -> Deploy keys`。

2. 配置 Jenkins

   ：

   - 在 `Manage Jenkins -> Manage Credentials` 添加 SSH 密钥。
   - 使用 SSH URL（如 `git@github.com:user/repo.git`）。

3. 优缺点

   ：

   - **优点**：安全性高。
   - **缺点**：密钥管理复杂。

### 5.2 使用 PAT 访问

1. 生成 PAT

   ：

   - 在 GitHub `Settings -> Developer settings -> Personal access tokens`，授予 `repo` 权限。

2. 配置 Jenkins

   ：

   - 添加 PAT 作为 `Username with password`。
   - 使用 HTTPS URL（如 `https://github.com/user/repo.git`）。

3. 优缺点

   ：

   - **优点**：配置简单。
   - **缺点**：PAT 泄露风险。

## 六、SCM 与 GitHub Webhooks 推送方式

### 6.1 SCM 轮询推送

- 配置

  ：

  - 配置 Git 仓库，设置 Cron 表达式（如 `H/5 * * * *`）。

- 流程

  ：

  1. 开发者推送代码。
  2. Jenkins 按 Cron 表达式检查。
  3. 触发 Pipeline。

- **适用场景**：网络隔离环境。

### 6.2 GitHub Webhooks 推送

- 配置

  ：

  - GitHub 端：添加 Webhook（`http://<Jenkins_URL>/github-webhook/`）。
  - Jenkins 端：启用 `GitHub hook trigger for GITScm polling`。

- 流程

  ：

  1. 开发者推送代码。
  2. GitHub 发送 POST 请求。
  3. Jenkins 触发 Pipeline。

- **适用场景**：实时性要求高。

## 七、不同环境的 Pipeline 配置

以下为 Java Spring Boot 应用的 FAT、UAT、生产环境的 Pipeline 配置，基于 Git Flow 分支，重点讲解 `script` 部分。

### 7.1 FAT 环境 Pipeline

- **分支**：`develop`
- **目的**：测试最新开发功能，快速迭代。

```groovy
pipeline {
    agent any
    environment {
        DOCKER_REGISTRY = 'docker.io'
        DOCKER_IMAGE = 'myapp/fat'
        DOCKER_TAG = "${env.BUILD_NUMBER}"
        KUBE_CONFIG = credentials('kubeconfig-fat')
    }
    triggers {
        pollSCM('H/5 * * * *') // 每 5 分钟随机轮询
    }
    stages {
        stage('Checkout') {
            steps {
                script {
                    // 拉取 develop 分支
                    git branch: 'develop', credentialsId: 'github-pat', url: 'https://github.com/user/repo.git'
                    // 记录提交信息
                    def commit = sh(script: 'git log -1 --pretty=%B', returnStdout: true).trim()
                    echo "Latest commit: ${commit}"
                }
            }
        }
        stage('Unit Test') {
            steps {
                script {
                    // 运行单元测试
                    sh 'mvn clean test'
                    // 检查测试结果
                    def testResult = sh(script: 'grep "<testsuite" target/surefire-reports/TEST-*.xml | wc -l', returnStdout: true).trim()
                    if (testResult == '0') {
                        error "No test cases found!"
                    }
                }
            }
        }
        stage('Build Docker Image') {
            steps {
                script {
                    // 构建镜像
                    sh """
                    docker build -t ${DOCKER_REGISTRY}/${DOCKER_IMAGE}:${DOCKER_TAG} \
                        --build-arg VERSION=${DOCKER_TAG} .
                    """
                    // 验证镜像
                    def imageExists = sh(script: "docker images ${DOCKER_REGISTRY}/${DOCKER_IMAGE}:${DOCKER_TAG} -q", returnStdout: true).trim()
                    if (!imageExists) {
                        error "Docker image build failed!"
                    }
                }
            }
        }
        stage('Push to Registry') {
            steps {
                script {
                    // 推送镜像
                    withCredentials([usernamePassword(credentialsId: 'docker-credentials', usernameVariable: 'DOCKER_USER', passwordVariable: 'DOCKER_PASS')]) {
                        sh 'echo $DOCKER_PASS | docker login ${DOCKER_REGISTRY} -u $DOCKER_USER --password-stdin'
                        sh "docker push ${DOCKER_REGISTRY}/${DOCKER_IMAGE}:${DOCKER_TAG}"
                    }
                }
            }
        }
        stage('Deploy to FAT') {
            steps {
                script {
                    // 部署到 FAT
                    withCredentials([file(credentialsId: 'kubeconfig-fat', variable: 'KUBECONFIG')]) {
                        sh """
                        kubectl --kubeconfig=\$KUBECONFIG apply -f k8s/fat-deployment.yaml
                        kubectl --kubeconfig=\$KUBECONFIG set image deployment/myapp \
                            myapp=${DOCKER_REGISTRY}/${DOCKER_IMAGE}:${DOCKER_TAG} --record
                        """
                        sh "kubectl --kubeconfig=\$KUBECONFIG rollout status deployment/myapp"
                    }
                }
            }
        }
    }
    post {
        always {
            script {
                sh 'docker logout'
            }
        }
        success {
            script {
                echo "FAT deployment completed: ${DOCKER_IMAGE}:${DOCKER_TAG}"
            }
        }
    }
}
```

**script 部分详解**：

- Checkout

  ：

  - 使用 PAT 拉取 `develop` 分支，适合快速迭代。
  - 记录最新提交信息（`git log -1`）用于日志追溯。

- Unit Test

  ：

  - 执行 `mvn clean test`，清理旧构建并运行测试。
  - 检查测试报告（`target/surefire-reports/`），确保有测试用例。

- Build Docker Image

  ：

  - 构建镜像，传递版本参数。
  - 验证镜像存在。

- Push to Registry

  ：

  - 使用 `withCredentials` 安全登录 Docker Registry。
  - 推送镜像。

- Deploy to FAT

  ：

  - 使用 `kubeconfig-fat` 部署到 Kubernetes。
  - 应用部署文件，更新镜像，验证部署状态（`kubectl rollout status`）。

- Post

  ：

  - 清理 Docker 登录。
  - 记录部署成功日志。

**触发器**：`pollSCM('H/5 * * * *')` 每 5 分钟轮询，快速响应 `develop` 分支变化。

### 7.2 UAT 环境 Pipeline

- **分支**：`release/*`（如 `release/v1.0.0`）
- **目的**：用户验收测试，验证发布前代码。

```groovy
pipeline {
    agent any
    environment {
        DOCKER_REGISTRY = 'docker.io'
        DOCKER_IMAGE = 'myapp/uat'
        DOCKER_TAG = "${env.BUILD_NUMBER}"
        KUBE_CONFIG = credentials('kubeconfig-uat')
    }
    triggers {
        githubPush() // Webhook 触发
    }
    stages {
        stage('Checkout') {
            steps {
                script {
                    // 拉取 release/* 分支
                    git branch: 'release/*', credentialsId: 'github-pat', url: 'https://github.com/user/repo.git'
                    // 验证分支
                    def currentBranch = sh(script: 'git rev-parse --abbrev-ref HEAD', returnStdout: true).trim()
                    if (!currentBranch.startsWith('release/')) {
                        error "Expected release/* branch, got ${currentBranch}"
                    }
                }
            }
        }
        stage('Unit Test') {
            steps {
                script {
                    // 运行单元测试，生成覆盖率
                    sh 'mvn clean test jacoco:report'
                    def coverage = sh(script: "grep '<coverage' target/site/jacoco/jacoco.xml | head -1", returnStdout: true).trim()
                    echo "Test coverage: ${coverage}"
                }
            }
        }
        stage('Integration Test') {
            steps {
                script {
                    // 运行集成测试
                    sh 'mvn verify -Pintegration'
                    def intTestResult = sh(script: 'grep "<testsuite" target/failsafe-reports/TEST-*.xml | wc -l', returnStdout: true).trim()
                    if (intTestResult == '0') {
                        error "No integration tests found!"
                    }
                }
            }
        }
        stage('Build Docker Image') {
            steps {
                script {
                    sh """
                    docker build -t ${DOCKER_REGISTRY}/${DOCKER_IMAGE}:${DOCKER_TAG} \
                        --build-arg VERSION=${DOCKER_TAG} .
                    """
                    def imageExists = sh(script: "docker images ${DOCKER_REGISTRY}/${DOCKER_IMAGE}:${DOCKER_TAG} -q", returnStdout: true).trim()
                    if (!imageExists) {
                        error "Docker image build failed!"
                    }
                }
            }
        }
        stage('Push to Registry') {
            steps {
                script {
                    withCredentials([usernamePassword(credentialsId: 'docker-credentials', usernameVariable: 'DOCKER_USER', passwordVariable: 'DOCKER_PASS')]) {
                        sh 'echo $DOCKER_PASS | docker login ${DOCKER_REGISTRY} -u $DOCKER_USER --password-stdin'
                        sh "docker push ${DOCKER_REGISTRY}/${DOCKER_IMAGE}:${DOCKER_TAG}"
                    }
                }
            }
        }
        stage('Deploy to UAT') {
            steps {
                script {
                    withCredentials([file(credentialsId: 'kubeconfig-uat', variable: 'KUBECONFIG')]) {
                        sh """
                        kubectl --kubeconfig=\$KUBECONFIG apply -f k8s/uat-deployment.yaml
                        kubectl --kubeconfig=\$KUBECONFIG set image deployment/myapp \
                            myapp=${DOCKER_REGISTRY}/${DOCKER_IMAGE}:${DOCKER_TAG} --record
                        """
                        sh "kubectl --kubeconfig=\$KUBECONFIG rollout status deployment/myapp"
                    }
                }
            }
        }
    }
    post {
        always {
            script {
                sh 'docker logout'
            }
        }
        success {
            script {
                mail to: 'team@example.com',
                     subject: "UAT Deployment Successful: ${env.JOB_NAME} #${env.BUILD_NUMBER}",
                     body: "UAT deployment completed for ${DOCKER_IMAGE}:${DOCKER_TAG}."
            }
        }
    }
}
```

**script 部分详解**：

- Checkout

  ：

  - 拉取 `release/*` 分支，匹配发布分支。
  - 验证分支名称（`git rev-parse`），确保正确。

- Unit Test

  ：

  - 执行 `mvn clean test jacoco:report`，生成覆盖率报告。
  - 记录覆盖率信息。

- Integration Test

  ：

  - 执行 `mvn verify -Pintegration`，运行集成测试。
  - 验证测试结果。

- **Build Docker Image**：同 FAT。

- **Push to Registry**：同 FAT。

- Deploy to UAT

  ：

  - 使用 `kubeconfig-uat` 部署。
  - 验证部署状态。

- Post

  ：

  - 清理 Docker 登录。
  - 发送邮件通知。

**触发器**：`githubPush()` 使用 Webhook，实时响应 `release/*` 分支推送。

### 7.3 生产环境 Pipeline

- **分支**：`main`
- **目的**：部署稳定代码，需人工审核。

```groovy
pipeline {
    agent any
    environment {
        DOCKER_REGISTRY = 'docker.io'
        DOCKER_IMAGE = 'myapp/prod'
        DOCKER_TAG = "${env.BUILD_NUMBER}"
        KUBE_CONFIG = credentials('kubeconfig-prod')
    }
    triggers {
        githubPush() // Webhook 触发
    }
    stages {
        stage('Checkout') {
            steps {
                script {
                    // 拉取 main 分支
                    git branch: 'main', credentialsId: 'github-ssh-key', url: 'git@github.com:user/repo.git'
                    def commitHash = sh(script: 'git rev-parse HEAD', returnStdout: true).trim()
                    echo "Deploying commit: ${commitHash}"
                }
            }
        }
        stage('Unit Test') {
            steps {
                script {
                    sh 'mvn clean test jacoco:report'
                    def coverage = sh(script: "grep '<coverage' target/site/jacoco/jacoco.xml | head -1", returnStdout: true).trim()
                    if (coverage.contains('line-rate="0"')) {
                        error "Test coverage is 0%!"
                    }
                    echo "Test coverage: ${coverage}"
                }
            }
        }
        stage('Integration Test') {
            steps {
                script {
                    sh 'mvn verify -Pintegration'
                    def intTestResult = sh(script: 'grep "<testsuite" target/failsafe-reports/TEST-*.xml | wc -l', returnStdout: true).trim()
                    if (intTestResult == '0') {
                        error "No integration tests found!"
                    }
                }
            }
        }
        stage('Build Docker Image') {
            steps {
                script {
                    sh """
                    docker build -t ${DOCKER_REGISTRY}/${DOCKER_IMAGE}:${DOCKER_TAG} \
                        --build-arg VERSION=${DOCKER_TAG} .
                    """
                    def imageExists = sh(script: "docker images ${DOCKER_REGISTRY}/${DOCKER_IMAGE}:${DOCKER_TAG} -q", returnStdout: true).trim()
                    if (!imageExists) {
                        error "Docker image build failed!"
                    }
                }
            }
        }
        stage('Push to Registry') {
            steps {
                script {
                    withCredentials([usernamePassword(credentialsId: 'docker-credentials', usernameVariable: 'DOCKER_USER', passwordVariable: 'DOCKER_PASS')]) {
                        sh 'echo $DOCKER_PASS | docker login ${DOCKER_REGISTRY} -u $DOCKER_USER --password-stdin'
                        sh "docker push ${DOCKER_REGISTRY}/${DOCKER_IMAGE}:${DOCKER_TAG}"
                    }
                }
            }
        }
        stage('Approve Deployment') {
            steps {
                script {
                    input message: 'Approve deployment to Production?', ok: 'Deploy'
                }
            }
        }
        stage('Deploy to Production') {
            steps {
                script {
                    withCredentials([file(credentialsId: 'kubeconfig-prod', variable: 'KUBECONFIG')]) {
                        sh """
                        kubectl --kubeconfig=\$KUBECONFIG apply -f k8s/prod-deployment.yaml
                        kubectl --kubeconfig=\$KUBECONFIG set image deployment/myapp \
                            myapp=${DOCKER_REGISTRY}/${DOCKER_IMAGE}:${DOCKER_TAG} --record
                        """
                        sh "kubectl --kubeconfig=\$KUBECONFIG rollout status deployment/myapp"
                        def podStatus = sh(script: "kubectl --kubeconfig=\$KUBECONFIG get pods -l app=myapp -o jsonpath='{.items[*].status.phase}'", returnStdout: true).trim()
                        if (!podStatus.contains('Running')) {
                            error "Production pods are not running!"
                        }
                    }
                }
            }
        }
    }
    post {
        always {
            script {
                sh 'docker logout'
            }
        }
        success {
            script {
                mail to: 'team@example.com',
                     subject: "Production Deployment Successful: ${env.JOB_NAME} #${env.BUILD_NUMBER}",
                     body: "Production deployment completed for ${DOCKER_IMAGE}:${DOCKER_TAG}."
            }
        }
        failure {
            script {
                mail to: 'team@example.com',
                     subject: "Production Deployment Failed: ${env.JOB_NAME} #${env.BUILD_NUMBER}",
                     body: "Production deployment failed. Please check Jenkins logs."
            }
        }
    }
}
```

**script 部分详解**：

- Checkout

  ：

  - 使用 SSH 拉取 `main` 分支，安全性更高。
  - 记录提交哈希。

- Unit Test

  ：

  - 检查覆盖率，防止 0% 覆盖率。

- Integration Test

  ：

  - 验证集成测试结果。

- **Build Docker Image**：同 UAT。

- **Push to Registry**：同 UAT。

- Approve Deployment

  ：

  - 使用 `input` 暂停 Pipeline，等待 Leader 批准。

- Deploy to Production

  ：

  - 使用 `kubeconfig-prod` 部署。
  - 验证 Pod 状态，确保服务运行。

- Post

  ：

  - 清理 Docker 登录。
  - 发送成功或失败邮件。

**触发器**：`githubPush()` 实时响应 `main` 分支推送。

## 八、从源码到 Docker 运行的完整链路

### 8.1 拉取源码

- **工具**：Git。

- 步骤

  ：

  - FAT：拉取 `develop`（PAT）。
  - UAT：拉取 `release/*`（PAT）。
  - PRO：拉取 `main`（SSH）。

- **注意**：验证分支和凭据。

### 8.2 运行单元测试

- **工具**：Maven、JUnit、JaCoCo。

- 步骤

  ：

  - FAT：`mvn clean test`。
  - UAT/PRO：`mvn clean test jacoco:report` + 集成测试。

- **注意**：检查覆盖率和测试结果。

### 8.3 构建 Docker 镜像

- **工具**：Docker。

- 步骤

  ：

  - 使用 

    ```
    Dockerfile
    ```

    ：

    ```dockerfile
    FROM openjdk:11
    COPY target/myapp.jar /app.jar
    ENTRYPOINT ["java", "-jar", "/app.jar"]
    ```

  - 执行 `docker build`。

- **注意**：优化镜像大小。

### 8.4 推送镜像到 Registry

- **工具**：Docker Registry。

- 步骤

  ：

  - 登录并推送镜像。

- **注意**：使用版本化标签。

### 8.5 部署到服务器

- FAT/UAT/PRO

  ：

  - 部署到 Kubernetes，使用各自 `kubeconfig`。

  - 示例部署文件：

    ```yaml
    apiVersion: apps/v1
    kind: Deployment
    metadata:
      name: myapp
    spec:
      replicas: 3
      selector:
        matchLabels:
          app: myapp
      template:
        metadata:
          labels:
            app: myapp
        spec:
          containers:
          - name: myapp
            image: docker.io/myapp/prod:123
            ports:
            - containerPort: 8080
    ```

- 注意

  ：

  - FAT：快速验证。
  - UAT：用户测试。
  - PRO：人工审核，高可用。

### 8.6 监控和日志

- **工具**：Prometheus、Grafana、Fluentd。

- 步骤

  ：

  - 收集 Jenkins 和 Kubernetes 日志。

- **注意**：配置告警。

## 九、总结

基于 Git Flow，FAT（`develop`）、UAT（`release/*`）、PRO（`main`）分别拉取不同分支，通过 Jenkins 的 SCM 轮询和 Webhooks 实现自动化 CI/CD。双周迭代中，普通程序员负责开发和测试，项目 Leader 协调发布和部署。详细的 Pipeline 配置和 `script` 脚本确保了从源码到生产环境的健壮部署流程。