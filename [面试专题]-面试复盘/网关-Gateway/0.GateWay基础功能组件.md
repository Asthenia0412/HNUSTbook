# 深入 Spring Cloud Gateway：ServerWebExchange 与 GatewayFilterChain 分析

Spring Cloud Gateway 是基于 Spring WebFlux 的 API 网关，核心在于其响应式编程模型。本文聚焦 `ServerWebExchange` 和 `GatewayFilterChain`，深入剖析它们的构造、作用以及 `Mono<Void>` 在过滤器链中的应用，解释为何使用 `Mono` 而非 `Flux`，并提供配置和请求链路细节。

## 一、Spring Cloud Gateway 配置概览

Spring Cloud Gateway 的配置主要通过 YAML 文件定义路由、断言和过滤器。以下是典型配置的归纳表格：

| 配置项                | 描述                                          | 示例                                                         |
| --------------------- | --------------------------------------------- | ------------------------------------------------------------ |
| **路由 ID**           | 路由的唯一标识                                | `route_id: user_service_route`                               |
| **目标 URI**          | 请求转发到的目标地址，支持 `lb://` 或直接 URL | `uri: lb://user-service`                                     |
| **断言 (Predicates)** | 路由匹配条件，如路径、方法等                  | `predicates: - Path=/api/users/**`                           |
| **过滤器 (Filters)**  | 路由处理逻辑，如添加请求头、限流等            | `filters: - AddRequestHeader=X-Request-From, Gateway`        |
| **全局过滤器**        | 应用于所有路由的过滤器                        | `default-filters: - AddResponseHeader=X-Gateway-Version, 1.0` |
| **限流配置**          | 使用 Redis 或内存实现请求限流                 | `filters: - name: RequestRateLimiter ...`                    |

**示例 YAML 配置：**

```yaml
spring:
  cloud:
    gateway:
      routes:
        - id: user_service_route
          uri: lb://user-service
          predicates:
            - Path=/api/users/**
          filters:
            - AddRequestHeader=X-Request-From, Gateway
            - name: RequestRateLimiter
              args:
                redis-rate-limiter.replenishRate: 10
                redis-rate-limiter.burstCapacity: 20
      default-filters:
        - AddResponseHeader=X-Gateway-Version, 1.0
```

## 二、ServerWebExchange 的构造与作用

### 构造

`ServerWebExchange` 是 Spring WebFlux 的核心接口，代表一次 HTTP 请求-响应的上下文。在 Spring Cloud Gateway 中，`ServerWebExchange` 由 `DefaultServerWebExchange` 实现，构造过程如下：

1. **Netty Server 接收请求**：Gateway 使用 Netty 作为底层服务器，接收客户端 HTTP 请求。

2. **HttpHandler 适配**：`ReactorHttpHandlerAdapter` 将 Netty 的请求转换为 WebFlux 的 `ServerHttpRequest` 和 `ServerHttpResponse`。

3. ServerWebExchange 创建

   ：

   ```
   DefaultServerWebExchange
   ```

    构造函数接收 

   ```
   ServerHttpRequest
   ```

   、

   ```
   ServerHttpResponse
   ```

    和 

   ```
   ServerWebExchangeAttributes
   ```

   （用于存储上下文属性），构建一个完整的上下文对象。

   ```java
   public DefaultServerWebExchange(ServerHttpRequest request, ServerHttpResponse response, 
                                   ServerWebExchangeAttributes attributes) {
       this.request = request;
       this.response = response;
       this.attributes = attributes;
   }
   ```

### 作用

`ServerWebExchange` 是请求处理链路的中心，贯穿整个 Gateway 处理流程，提供以下功能：

- **请求信息**：通过 `getRequest()` 获取 `ServerHttpRequest`，包含路径、头信息、查询参数等。
- **响应信息**：通过 `getResponse()` 获取 `ServerHttpResponse`，允许修改状态码、响应头等。
- **上下文属性**：通过 `getAttributes()` 存储键值对，供过滤器间共享数据（如认证信息）。
- **响应式支持**：基于 Reactor，提供异步访问请求体的 `Mono<DataBuffer>` 或 `Flux<DataBuffer>`。

**示例**：在过滤器中修改请求头：

```java
exchange.getRequest().mutate().header("X-Custom-Header", "Value").build();
```

## 三、GatewayFilterChain 的构造与作用

### 构造

`GatewayFilterChain` 是 Gateway 中过滤器执行的核心组件，由 `FilteringWebHandler` 构建。其构造过程如下：

1. **路由匹配**：`RoutePredicateHandlerMapping` 根据断言匹配请求，确定目标路由。

2. **过滤器收集**：`FilteringWebHandler` 收集全局过滤器（`GlobalFilter`）和路由特定的 `GatewayFilter`，按 `order` 属性排序。

3. 链式构建

   ：通过 

   ```
   DefaultGatewayFilterChain
   ```

    构造函数，将过滤器列表封装为一个链式结构。

   ```java
   public DefaultGatewayFilterChain(List<GatewayFilter> filters) {
       this.filters = filters;
       this.index = 0;
   }
   ```

### 作用

`GatewayFilterChain` 按顺序执行过滤器，处理请求和响应：

- **Pre 处理**：在转发请求到目标服务前，执行认证、限流等逻辑。
- **Proxy Exchange**：通过 `WebClient` 将请求转发到目标服务。
- **Post 处理**：在收到目标服务响应后，执行日志记录、添加响应头等逻辑。

过滤器链通过递归调用 `filter` 方法实现：

```java
public Mono<Void> filter(ServerWebExchange exchange) {
    return this.filters.get(index) != null ?
            this.filters.get(index).filter(exchange, new DefaultGatewayFilterChain(filters, index + 1)) :
            Mono.empty();
}
```

## 四、Mono 的使用与分析

在 Gateway 的过滤器中，常见代码模式如下：

```java
public class CustomGatewayFilter implements GatewayFilter {
    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        // Pre 处理
        exchange.getRequest().mutate().header("X-Custom-Header", "Value").build();
        return chain.filter(exchange).then(Mono.fromRunnable(() -> {
            // Post 处理
            exchange.getResponse().getHeaders().add("X-Response-Header", "Done");
        }));
    }
}
```

### Mono 的作用

- **异步信号**：`Mono<Void>` 表示一个异步操作的完成信号，不携带数据。它用于通知 Reactor 管道某个操作（如过滤器执行）已完成。
- **链式处理**：`chain.filter(exchange)` 返回 `Mono<Void>`，表示下游过滤器和目标服务的执行完成。`then` 运算符等待其完成后再执行 Post 处理。
- **无状态操作**：过滤器通常只修改 `ServerWebExchange` 的状态（如请求头、响应头），无需返回数据，因此 `Mono<Void>` 适合表示“完成”。

### 为什么不用 Flux？

- **单次请求**：Gateway 每次处理一个 HTTP 请求-响应对，`Mono` 适合表示单一事件的结果，而 `Flux` 用于处理流式数据（如 WebSocket 或 SSE）。
- **语义清晰**：`Mono<Void>` 明确表示一次请求处理完成，避免 `Flux` 可能带来的流式处理误解。
- **性能优化**：`Mono` 的单值处理比 `Flux` 的流处理更轻量，减少 Reactor 调度开销。

**示例解析**：

```java
return chain.filter(exchange).then(Mono.fromRunnable(() -> {
    exchange.getResponse().getHeaders().add("X-Response-Header", "Done");
}));
```

- `chain.filter(exchange)`：调用下一个过滤器或目标服务，返回 `Mono<Void>`。
- `then(Mono.fromRunnable(...))`：等待 `chain.filter` 完成，执行 Post 处理（如添加响应头），`Mono.fromRunnable` 将同步代码包装为异步 `Mono`。
- 整个方法返回 `Mono<Void>`，确保过滤器链异步执行。

## 五、请求链路分析

Gateway 的请求处理链路如下：

1. **客户端请求**：发送 HTTP 请求到 Gateway。

2. **Netty Server**：接收请求，创建 `ServerHttpRequest` 和 `ServerHttpResponse`。

3. **RoutePredicateHandlerMapping**：匹配路由，创建 `ServerWebExchange`。

4. **FilteringWebHandler**：构建 `GatewayFilterChain`，包含 `GlobalFilter` 和 `GatewayFilter`。

5. GatewayFilterChain

   ：

   - **Pre Filters**：修改 `ServerWebExchange`，如添加请求头、限流。
   - **WebClient**：异步转发请求到目标服务。
   - **Post Filters**：处理响应，如添加响应头。

6. **响应返回**：通过 Netty 返回响应。

**关键节点**：

- **ServerWebExchange**：贯穿整个链路，存储请求、响应和上下文。
- **GatewayFilterChain**：控制过滤器执行顺序。
- **WebClient**：基于 Reactor Netty，执行异步 HTTP 调用。

## 六、响应式编程的应用

Gateway 基于 Spring WebFlux，使用 Reactor 的核心概念：

- **Mono**：处理单次请求-响应，如过滤器链的执行。
- **ServerWebExchange**：提供响应式上下文，支持异步修改。
- **Backpressure**：通过 Reactor 控制流量，防止过载。
- **WebClient**：异步调用目标服务，返回 `Mono` 或 `Flux`。

## 七、模拟面试官深入提问

**问题 1**：`ServerWebExchange` 如何在过滤器间共享状态？
**回答**：通过 `getAttributes()` 方法存储键值对，过滤器可读写这些属性。例如：

```java
exchange.getAttributes().put("userId", "123");
```

**深入 1**：如果多个过滤器并发修改属性，会不会有线程安全问题？
**回答**：Gateway 使用 Reactor 的单线程事件循环模型，过滤器链按顺序执行，`ServerWebExchange` 的属性修改是线程安全的。  

**问题 2**：为什么 `GatewayFilterChain` 使用 `Mono<Void>` 而不是同步方法？
**回答**：`Mono<Void>` 允许异步处理，支持非阻塞 I/O。同步方法会阻塞 Netty 线程，降低并发性能。
**深入 1**：如果过滤器中有阻塞操作（如数据库查询），如何处理？
**回答**：应将阻塞操作包装在 `Mono.fromCallable` 并调度到 `Schedulers.boundedElastic()`，避免阻塞 Reactor 线程。  

**问题 3**：`then` 运算符在过滤器中的作用是什么？
**回答**：`then` 等待前一个 `Mono` 完成，执行后续逻辑，确保 Pre 和 Post 处理的顺序。
**深入 1**：如果 `chain.filter` 抛出异常，`then` 会执行吗？
**回答**：不会，需使用 `onErrorResume` 捕获异常并定义回退逻辑。  

## 八、总结

`ServerWebExchange` 和 `GatewayFilterChain` 是 Spring Cloud Gateway 的核心，分别提供请求上下文和过滤器执行逻辑。`Mono<Void>` 确保异步非阻塞处理，适合单次请求-响应的场景，而非流式数据的 `Flux`。理解它们的构造和作用，有助于优化 Gateway 的性能和扩展性，尤其在限流、认证等场景中。