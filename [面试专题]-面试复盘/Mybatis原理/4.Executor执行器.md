# MyBatis Executor 详解与面试问题解析

## 一、MyBatis Executor 介绍

MyBatis 是一个流行的 Java 持久化框架，其核心组件之一是 **Executor**，负责执行 SQL 语句并处理数据库交互。Executor 是 MyBatis 的执行器，位于 MyBatis 的核心层，**负责将 Mapper 接口的调用转化为实际的数据库操作**。它**封装了底层的 JDBC** 操作，提供了更高的抽象层，简化了数据库访问。

### 1. Executor 的作用

Executor 的主要职责包括：很好记忆：先跑SQL，跑完SQL就有结果返回，要对结果集做映射。SQL涉及到事务，所以得事务管理。SQL的结果要存入缓存，所以有缓存的管理。

- **SQL 执行**：将 Mapper 中的 SQL 语句发送到数据库并获取结果。
- **事务管理**：控制事务的提交、回滚和关闭。
- **缓存管理**：处理一级缓存（Session 级别缓存）和二级缓存。
- **结果映射**：将数据库查询结果映射为 Java 对象。

### 2. Executor 的类型

MyBatis 提供了多种 Executor 实现，每种适用于不同的场景：

1. SimpleExecutor（简单执行器）

   - 默认的执行器。
   - 每次执行 SQL 时都会创建一个新的 `PreparedStatement`，执行完后关闭。
   - 适合简单的、单次 SQL 执行场景，不涉及复杂的事务或批量操作。

2. ReuseExecutor（重用执行器）

   - 重用 `PreparedStatement`，避免重复创建和销毁。
   - 通过缓存 `PreparedStatement` 对象来提高性能。
   - 适合重复执行相同 SQL 的场景。

3. BatchExecutor（批量执行器）

   - 针对批量操作优化，将多条 SQL 语句缓存到 `Statement` 中，统一发送到数据库。
   - 适合批量插入、更新等操作，能显著减少数据库交互次数。

4. CachingExecutor

   （缓存执行器）

   - 装饰器模式，包装其他 Executor，增加了二级缓存的功能。
   - 在查询时会先检查二级缓存，命中则直接返回结果，未命中再委托给底层 Executor。

### 3. Executor 的工作流程

1. **初始化**：MyBatis 在创建 `SqlSession` 时会根据配置选择合适的 Executor 实现。

2. SQL 执行

   ：

   - Executor 接收 Mapper 的调用，解析 SQL 语句。
   - 调用 JDBC 的 `Statement` 或 `PreparedStatement` 执行 SQL。
   - 如果启用了缓存，会先查询缓存。

3. **结果处理**：将数据库返回的结果通过 `ResultSetHandler` 映射为 Java 对象。

4. **事务管理**：根据 `SqlSession` 的配置，提交或回滚事务。

### 4. 一级缓存与二级缓存

- 一级缓存

  （Local Cache）：

  - 默认开启，作用于 `SqlSession` 级别。
  - 同一个 `SqlSession` 内，相同的 SQL 查询会缓存结果，避免重复查询数据库。
  - 当执行更新操作（插入、更新、删除）或 `SqlSession` 关闭时，一级缓存会被清空。

- 二级缓存

  （Global Cache）：

  - 需要手动配置开启，作用于 `SqlSessionFactory` 级别。
  - 由 `CachingExecutor` 管理，跨 `SqlSession` 共享。
  - 适合数据不常变更的场景，但需要注意缓存一致性问题。

### 5. Executor 的扩展性

MyBatis 允许通过插件（Interceptor）对 Executor 进行扩展。例如，可以通过自定义插件拦截 Executor 的 `query` 或 `update` 方法，实现日志记录、SQL 改写或性能监控等功能。

## 二、模拟面试官提问及解析

以下是模拟的面试问题，涵盖 Executor 的核心知识点，并附详细解析。

### 问题 1：MyBatis 中的 Executor 有哪些类型？它们分别适用于什么场景？

**回答**：
MyBatis 提供了四种 Executor 实现：

- **SimpleExecutor**：默认执行器，适合简单的单次 SQL 执行，每次创建新的 `PreparedStatement`。
- **ReuseExecutor**：重用 `PreparedStatement`，适合重复执行相同 SQL 的场景，能减少创建 `PreparedStatement` 的开销。
- **BatchExecutor**：批量执行器，适合批量插入或更新操作，将多条 SQL 缓存后统一执行，减少数据库交互。
- **CachingExecutor**：包装其他 Executor，管理二级缓存，适合数据不常变更的查询场景。

**解析**：
这个问题考察对 Executor 类型的理解和适用场景。需要明确每种 Executor 的特点和使用场景，特别注意 BatchExecutor 和 CachingExecutor 的特殊用途。面试中可以结合实际案例，例如“批量插入用户数据时用 BatchExecutor 提高性能”。

### 问题 2：MyBatis 的一级缓存和二级缓存分别由谁管理？如何避免缓存导致的数据不一致问题？

**回答**：

- **一级缓存**：由 `BaseExecutor` 管理，作用于 `SqlSession` 级别，默认开启。同一 `SqlSession` 内，相同的 SQL 查询会命中缓存。

- **二级缓存**：由 `CachingExecutor` 管理，作用于 `SqlSessionFactory` 级别，需手动配置开启。

- 避免数据不一致

  ：

  - 一级缓存：执行更新操作或关闭 `SqlSession` 时清空缓存。
  - 二级缓存：配置合理的缓存策略（如设置刷新间隔），或在数据频繁变更的场景禁用二级缓存。
  - 使用版本控制或时间戳机制，确保缓存数据与数据库一致。

**解析**：
这个问题考察缓存机制的原理和应用。需要清楚一级缓存和二级缓存的生命周期、作用范围以及潜在问题。实际开发中，二级缓存因一致性问题较少使用，需特别说明其适用场景。

### 问题 3：如何通过 MyBatis 插件自定义 Executor 的行为？

**回答**：
MyBatis 提供了插件机制（Interceptor），可以拦截 Executor 的方法（如 `query`、`update`）。实现步骤：

1. 创建一个类实现 `Interceptor` 接口，重写 `intercept` 方法。

2. 使用 

   ```
   @Intercepts
   ```

    注解指定拦截 Executor 的方法，例如：

   ```java
   @Intercepts({
       @Signature(type = Executor.class, method = "query", args = {MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class})
   })
   ```

3. 在 `intercept` 方法中实现自定义逻辑，如日志记录或 SQL 改写。

4. 在 MyBatis 配置文件中注册插件：

   ```xml
   <plugins>
       <plugin interceptor="com.example.MyInterceptor"/>
   </plugins>
   ```

**解析**：
这个问题考察 MyBatis 的扩展能力。需要熟悉插件机制的实现原理，清楚 `@Intercepts` 和 `@Signature` 的用法，以及 Executor 可拦截的方法。实际案例（如记录 SQL 执行时间）能加深回答的说服力。

## 三、选择题及解析

以下是关于 MyBatis Executor 的选择题，附带详细解析和答案。

### 选择题 1

**问题**：以下哪种 Executor 适合处理批量插入操作？
A. SimpleExecutor
B. ReuseExecutor
C. BatchExecutor
D. CachingExecutor  

**正确答案**：C. BatchExecutor  

**解析**：

- **SimpleExecutor**：每次执行 SQL 都会创建新的 `PreparedStatement`，不适合批量操作。
- **ReuseExecutor**：重用 `PreparedStatement`，适合重复执行相同 SQL，但不优化批量操作。
- **BatchExecutor**：专门为批量操作设计，将多条 SQL 缓存后统一执行，减少数据库交互，适合批量插入。
- **CachingExecutor**：用于管理二级缓存，与批量插入无关。

**详尽答案**：
BatchExecutor 通过 JDBC 的 `addBatch` 和 `executeBatch` 方法，将多条 SQL 语句缓存到 `Statement` 中，统一发送到数据库，显著提高批量插入的性能。例如，插入 1000 条记录时，BatchExecutor 只需要一次数据库交互，而 SimpleExecutor 需要 1000 次。

### 选择题 2

**问题**：以下关于 MyBatis 一级缓存的描述，正确的是？
A. 一级缓存由 CachingExecutor 管理
B. 一级缓存默认关闭，需手动配置开启
C. 一级缓存作用于 SqlSession 级别
D. 一级缓存会在 SqlSessionFactory 关闭时清空  

**正确答案**：C. 一级缓存作用于 SqlSession 级别  

**解析**：

- **A. 错误**：一级缓存由 `BaseExecutor` 管理，`CachingExecutor` 负责二级缓存。
- **B. 错误**：一级缓存默认开启，无需手动配置。
- **C. 正确**：一级缓存作用于 `SqlSession` 级别，同一 `SqlSession` 内相同 SQL 查询会命中缓存。
- **D. 错误**：一级缓存随 `SqlSession` 关闭而清空，而非 `SqlSessionFactory`。

**详尽答案**：
一级缓存是 MyBatis 的默认功能，存储在 `SqlSession` 内的 `PerpetualCache` 对象中。同一 `SqlSession` 内，执行相同的 SQL 查询会直接从缓存中获取结果。当执行更新操作（如插入、更新、删除）或关闭 `SqlSession` 时，缓存会被清空，以确保数据一致性。

## 四、总结

MyBatis 的 Executor 是其核心组件，负责 SQL 执行、事务管理和缓存处理。理解不同类型的 Executor（如 SimpleExecutor、ReuseExecutor、BatchExecutor 和 CachingExecutor）及其适用场景，对开发高效的数据库操作至关重要。此外，掌握一级缓存和二级缓存的机制，以及通过插件扩展 Executor 的能力，可以帮助开发者更好地优化 MyBatis 应用。

希望这篇博客能帮助您深入理解 MyBatis Executor，并在面试中从容应对相关问题！