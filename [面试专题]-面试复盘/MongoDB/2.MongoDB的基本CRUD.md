# MongoDB CRUD 教程（Java）：从基础操作到复杂业务场景与面试八股

以下是MongoDB基础CRUD操作及关键API参数的详细归纳表格，涵盖 **Java Driver** 的核心用法（基于MongoDB Java Driver 4.x+版本）：

------

### **1. 基础CRUD操作对照表**

| **操作类型** | **方法**           | **Java SDK示例**                                             | **返回值**          | **关键参数**                                      |
| ------------ | ------------------ | ------------------------------------------------------------ | ------------------- | ------------------------------------------------- |
| **插入**     | `insertOne`        | `collection.insertOne(new Document("name", "Alice"))`        | `InsertOneResult`   | `Document` 或 POJO                                |
|              | `insertMany`       | `collection.insertMany(List<Document>)`                      | `InsertManyResult`  | `List<Document>`，支持`ordered`（是否按顺序插入） |
| **查询**     | `find`             | `collection.find(Filters.eq("name", "Alice"))`               | `FindIterable<T>`   | `Filter`、`Projection`、`Sort`、`limit`/`skip`    |
|              | `findOneAnd...`    | `findOneAndUpdate(filter, update)`                           | `T`（文档或POJO）   | `returnDocument`（返回修改前/后文档）、`upsert`   |
| **更新**     | `updateOne`        | `collection.updateOne(Filters.eq("name", "Alice"), Updates.set("age", 25))` | `UpdateResult`      | `Filter`、`Update`、`upsert`                      |
|              | `updateMany`       | `collection.updateMany(filter, update)`                      | `UpdateResult`      | 同上                                              |
|              | `replaceOne`       | `collection.replaceOne(filter, newDoc)`                      | `UpdateResult`      | 完全替换文档（不保留原字段）                      |
| **删除**     | `deleteOne`        | `collection.deleteOne(Filters.eq("name", "Alice"))`          | `DeleteResult`      | `Filter`                                          |
|              | `deleteMany`       | `collection.deleteMany(Filters.gt("age", 30))`               | `DeleteResult`      | 同上                                              |
|              | `findOneAndDelete` | `collection.findOneAndDelete(filter)`                        | `T`（被删除的文档） | 返回被删除的文档                                  |

------

### **2. `Filters` 常用查询条件**

| **操作符** | **Java方法**                        | **示例**                                                     | **等效BSON**                      |
| ---------- | ----------------------------------- | ------------------------------------------------------------ | --------------------------------- |
| 等于       | `Filters.eq`                        | `Filters.eq("name", "Alice")`                                | `{ name: "Alice" }`               |
| 不等于     | `Filters.ne`                        | `Filters.ne("age", 30)`                                      | `{ age: { $ne: 30 } }`            |
| 大于/小于  | `Filters.gt` / `Filters.lt`         | `Filters.gt("age", 18)`                                      | `{ age: { $gt: 18 } }`            |
| 范围查询   | `Filters.and` + `gt/lt`             | `Filters.and(Filters.gt("age", 18), Filters.lt("age", 60))`  | `{ $and: [{age:{$gt:18}}, ...]}`  |
| 包含于数组 | `Filters.in`                        | `Filters.in("status", "A", "B")`                             | `{ status: { $in: ["A", "B"] } }` |
| 正则匹配   | `Filters.regex`                     | `Filters.regex("name", "^Al")`                               | `{ name: /^Al/ }`                 |
| 数组查询   | `Filters.all` / `Filters.elemMatch` | `Filters.all("tags", "A", "B")`                              | `{ tags: { $all: ["A", "B"] } }`  |
| 逻辑组合   | `Filters.and` / `Filters.or`        | `Filters.or(Filters.eq("name", "Alice"), Filters.eq("name", "Bob"))` | `{ $or: [{name:"Alice"}, ...]}`   |

------

### **3. `Updates` 常用修改操作符**

| **操作符** | **Java方法**                | **示例**                               | **等效BSON**                          |
| ---------- | --------------------------- | -------------------------------------- | ------------------------------------- |
| 设置字段值 | `Updates.set`               | `Updates.set("age", 25)`               | `{ $set: { age: 25 } }`               |
| 递增字段值 | `Updates.inc`               | `Updates.inc("count", 1)`              | `{ $inc: { count: 1 } }`              |
| 删除字段   | `Updates.unset`             | `Updates.unset("deprecatedField")`     | `{ $unset: { deprecatedField: "" } }` |
| 数组操作   | `Updates.push` / `pull`     | `Updates.push("tags", "newTag")`       | `{ $push: { tags: "newTag" } }`       |
| 条件更新   | `Updates.combine` + `$cond` | 组合多个操作（见下方代码）             | 复合操作                              |
| 重命名字段 | `Updates.rename`            | `Updates.rename("oldName", "newName")` | `{ $rename: { oldName: "newName" } }` |

**示例：组合更新操作**

```
Updates.combine(
    Updates.set("name", "Alice"),
    Updates.inc("count", 1),
    Updates.currentDate("lastModified")
)
```

------

### **4. 其他关键参数**

| **配置项**                | **Java SDK设置方法**                                 | **说明**                                     |
| ------------------------- | ---------------------------------------------------- | -------------------------------------------- |
| 读写关注（Write Concern） | `collection.withWriteConcern(WriteConcern.MAJORITY)` | 控制写操作的持久性级别（如`W1`、`MAJORITY`） |
| 超时设置                  | `collection.withTimeout(5, TimeUnit.SECONDS)`        | 设置操作超时时间                             |
| 批量操作选项              | `BulkWriteOptions().ordered(false)`                  | 无序批量操作（提升性能）                     |
| 聚合选项                  | `AggregateOptions().allowDiskUse(true)`              | 允许聚合使用临时文件（处理大数据集）         |

------

### **5. 事务与原子性**

| **操作**  | **Java代码片段**                                             | **注意点**                |
| --------- | ------------------------------------------------------------ | ------------------------- |
| 开启事务  | `session.startTransaction()`                                 | 需在`ClientSession`中调用 |
| 提交/回滚 | `session.commitTransaction()` / `session.abortTransaction()` | 必须显式调用              |
| 事务超时  | `TransactionOptions.builder().maxCommitTime(10, TimeUnit.SECONDS).build()` | 防止长事务阻塞            |

------

### **总结**

- **Filters**：用于构建查询条件（类似SQL的WHERE子句）。
- **Updates**：提供原子性字段修改操作（如`$set`、`$inc`）。
- **选项配置**：通过`WriteConcern`、`BulkWriteOptions`等控制行为。
- **事务**：需显式管理`ClientSession`，适用于多文档原子操作。

此表格可作为Java开发者快速查阅MongoDB CRUD API的参考手册。

MongoDB 是一个流行的 NoSQL 数据库，以其灵活的文档模型和高扩展性广泛应用于现代应用开发。本文将详细介绍如何使用 Java 的 MongoDB 驱动实现基本 CRUD（创建、读取、更新、删除）操作，结合一个复杂的电商库存管理业务场景进行示例说明，并针对面试中常见的“八股文”问题提供深入解答，助你在技术面试中游刃有余。

## 一、MongoDB CRUD 基础操作（基于 Java）

我们将使用 MongoDB Java Driver（版本 4.x）实现 CRUD 操作。以下示例基于 Java 17 和 Maven 项目。

### 1. 环境准备

#### 1.1 添加依赖

在 `pom.xml` 中添加 MongoDB Java Driver 依赖：

```xml
<dependency>
    <groupId>org.mongodb</groupId>
    <artifactId>mongodb-driver-sync</artifactId>
    <version>5.2.0</version>
</dependency>
```

#### 1.2 连接 MongoDB

建立 MongoDB 连接：

```java
import com.mongodb.client.*;
import org.bson.Document;

public class MongoDBConnection {
    private static MongoClient mongoClient;

    public static MongoClient connectDB() {
        if (mongoClient == null) {
            String uri = "mongodb://localhost:27017";
            mongoClient = MongoClients.create(uri);
            System.out.println("Connected to MongoDB");
        }
        return mongoClient;
    }

    public static void closeDB() {
        if (mongoClient != null) {
            mongoClient.close();
            System.out.println("Connection closed");
        }
    }
}
```

### 2. 创建（Create）

插入单个文档：

```java
import com.mongodb.client.MongoCollection;
import com.mongodb.client.MongoDatabase;
import org.bson.Document;

public class CreateExample {
    public static void createDocument(MongoClient client) {
        MongoDatabase db = client.getDatabase("shop");
        MongoCollection<Document> collection = db.getCollection("products");

        Document product = new Document("name", "Laptop")
                .append("price", 999.99)
                .append("stock", 50)
                .append("category", "Electronics")
                .append("createdAt", new java.util.Date());

        collection.insertOne(product);
        System.out.println("Inserted document with _id: " + product.get("_id"));
    }
}
```

批量插入文档：

```java
import com.mongodb.client.MongoCollection;
import org.bson.Document;
import java.util.Arrays;

public class CreateExample {
    public static void createMultipleDocuments(MongoClient client) {
        MongoDatabase db = client.getDatabase("shop");
        MongoCollection<Document> collection = db.getCollection("products");

        Document product1 = new Document("name", "Phone")
                .append("price", 599.99)
                .append("stock", 100)
                .append("category", "Electronics");

        Document product2 = new Document("name", "Headphones")
                .append("price", 99.99)
                .append("stock", 200)
                .append("category", "Accessories");

        collection.insertMany(Arrays.asList(product1, product2));
        System.out.println("Inserted multiple documents");
    }
}
```

### 3. 读取（Read）

查询单个文档：

```java
import com.mongodb.client.MongoCollection;
import org.bson.Document;
import static com.mongodb.client.model.Filters.eq;

public class ReadExample {
    public static void findDocument(MongoClient client) {
        MongoDatabase db = client.getDatabase("shop");
        MongoCollection<Document> collection = db.getCollection("products");

        Document document = collection.find(eq("name", "Laptop")).first();
        System.out.println("Found document: " + document);
    }
}
```

查询多个文档：

```java
import com.mongodb.client.MongoCollection;
import com.mongodb.client.FindIterable;
import org.bson.Document;
import static com.mongodb.client.model.Filters.eq;

public class ReadExample {
    public static void findMultipleDocuments(MongoClient client) {
        MongoDatabase db = client.getDatabase("shop");
        MongoCollection<Document> collection = db.getCollection("products");

        FindIterable<Document> documents = collection.find(eq("category", "Electronics"));
        for (Document doc : documents) {
            System.out.println("Found document: " + doc);
        }
    }
}
```

高级查询（使用比较和逻辑运算符）：

```java
import com.mongodb.client.MongoCollection;
import com.mongodb.client.FindIterable;
import org.bson.Document;
import static com.mongodb.client.model.Filters.*;

public class ReadExample {
    public static void advancedQuery(MongoClient client) {
        MongoDatabase db = client.getDatabase("shop");
        MongoCollection<Document> collection = db.getCollection("products");

        FindIterable<Document> documents = collection.find(
                and(
                        gte("price", 500),
                        lte("price", 1000),
                        in("category", "Electronics", "Accessories")
                )
        ).sort(new Document("price", -1)).limit(10);

        for (Document doc : documents) {
            System.out.println("Advanced query result: " + doc);
        }
    }
}
```

### 4. 更新（Update）

更新单个文档：

```java
import com.mongodb.client.MongoCollection;
import com.mongodb.client.result.UpdateResult;
import org.bson.Document;
import static com.mongodb.client.model.Filters.eq;
import static com.mongodb.client.model.Updates.*;

public class UpdateExample {
    public static void updateDocument(MongoClient client) {
        MongoDatabase db = client.getDatabase("shop");
        MongoCollection<Document> collection = db.getCollection("products");

        UpdateResult result = collection.updateOne(
                eq("name", "Laptop"),
                combine(
                        set("price", 1099.99),
                        set("updatedAt", new java.util.Date())
                )
        );
        System.out.println("Updated " + result.getModifiedCount() + " document");
    }
}
```

批量更新：

```java
import com.mongodb.client.MongoCollection;
import com.mongodb.client.result.UpdateResult;
import org.bson.Document;
import static com.mongodb.client.model.Filters.eq;
import static com.mongodb.client.model.Updates.inc;

public class UpdateExample {
    public static void updateMultipleDocuments(MongoClient client) {
        MongoDatabase db = client.getDatabase("shop");
        MongoCollection<Document> collection = db.getCollection("products");

        UpdateResult result = collection.updateMany(
                eq("category", "Electronics"),
                inc("stock", -10)
        );
        System.out.println("Updated " + result.getModifiedCount() + " documents");
    }
}
```

### 5. 删除（Delete）

删除单个文档：

```java
import com.mongodb.client.MongoCollection;
import com.mongodb.client.result.DeleteResult;
import org.bson.Document;
import static com.mongodb.client.model.Filters.eq;

public class DeleteExample {
    public static void deleteDocument(MongoClient client) {
        MongoDatabase db = client.getDatabase("shop");
        MongoCollection<Document> collection = db.getCollection("products");

        DeleteResult result = collection.deleteOne(eq("name", "Headphones"));
        System.out.println("Deleted " + result.getDeletedCount() + " document");
    }
}
```

批量删除：

```java
import com.mongodb.client.MongoCollection;
import com.mongodb.client.result.DeleteResult;
import org.bson.Document;
import static com.mongodb.client.model.Filters.lte;

public class DeleteExample {
    public static void deleteMultipleDocuments(MongoClient client) {
        MongoDatabase db = client.getDatabase("shop");
        MongoCollection<Document> collection = db.getCollection("products");

        DeleteResult result = collection.deleteMany(lte("stock", 0));
        System.out.println("Deleted " + result.getDeletedCount() + " documents");
    }
}
```

### 6. 完整示例代码

以下是整合上述操作的完整 Java 程序：

```java
import com.mongodb.client.*;

public class MongoDBCRUDExample {
    public static void main(String[] args) {
        MongoClient client = MongoDBConnection.connectDB();
        try {
            CreateExample.createDocument(client);
            CreateExample.createMultipleDocuments(client);
            ReadExample.findDocument(client);
            ReadExample.findMultipleDocuments(client);
            ReadExample.advancedQuery(client);
            UpdateExample.updateDocument(client);
            UpdateExample.updateMultipleDocuments(client);
            DeleteExample.deleteDocument(client);
            DeleteExample.deleteMultipleDocuments(client);
        } finally {
            MongoDBConnection.closeDB();
        }
    }
}
```

## 二、复杂业务场景：电商库存管理系统

我们以一个电商平台的库存管理系统为例，涉及商品（`products`）、订单（`orders`）和用户（`users`）三个集合，展示如何使用 Java 和 MongoDB 实现核心业务逻辑。

### 1. 数据模型

```java
// 商品
{
  "_id": ObjectId,
  "name": String,
  "price": Double,
  "stock": Integer,
  "category": String,
  "createdAt": Date,
  "updatedAt": Date
}

// 订单
{
  "_id": ObjectId,
  "userId": ObjectId,
  "products": [
    {
      "productId": ObjectId,
      "quantity": Integer
    }
  ],
  "totalPrice": Double,
  "status": String, // "pending", "completed", "cancelled"
  "createdAt": Date
}

// 用户
{
  "_id": ObjectId,
  "username": String,
  "email": String,
  "createdAt": Date
}
```

### 2. 业务场景：创建订单并更新库存

用户下单时，需检查库存、创建订单并扣减库存。

```java
import com.mongodb.client.*;
import com.mongodb.client.model.Updates;
import org.bson.Document;
import org.bson.types.ObjectId;
import java.util.ArrayList;
import java.util.List;
import static com.mongodb.client.model.Filters.eq;

public class OrderService {
    public static ObjectId createOrder(MongoClient client, ObjectId userId, List<Document> productOrders) {
        MongoDatabase db = client.getDatabase("shop");
        MongoCollection<Document> productsCollection = db.getCollection("products");
        MongoCollection<Document> ordersCollection = db.getCollection("orders");

        try (ClientSession session = client.startSession()) {
            session.startTransaction();
            try {
                // 检查库存
                for (Document order : productOrders) {
                    ObjectId productId = order.getObjectId("productId");
                    Integer quantity = order.getInteger("quantity");
                    Document product = productsCollection.find(eq("_id", productId)).first();
                    if (product == null || product.getInteger("stock") < quantity) {
                        throw new RuntimeException("Insufficient stock for product " + productId);
                    }
                }

                // 计算总价
                double totalPrice = 0;
                for (Document order : productOrders) {
                    ObjectId productId = order.getObjectId("productId");
                    Integer quantity = order.getInteger("quantity");
                    Document product = productsCollection.find(eq("_id", productId)).first();
                    totalPrice += product.getDouble("price") * quantity;
                }

                // 创建订单
                Document order = new Document("userId", userId)
                        .append("products", productOrders)
                        .append("totalPrice", totalPrice)
                        .append("status", "pending")
                        .append("createdAt", new java.util.Date());
                ordersCollection.insertOne(session, order);

                // 更新库存
                for (Document order : productOrders) {
                    ObjectId productId = order.getObjectId("productId");
                    Integer quantity = order.getInteger("quantity");
                    productsCollection.updateOne(
                            session,
                            eq("_id", productId),
                            Updates.combine(
                                    Updates.inc("stock", -quantity),
                                    Updates.set("updatedAt", new java.util.Date())
                            )
                    );
                }

                session.commitTransaction();
                System.out.println("Order created with _id: " + order.get("_id"));
                return order.getObjectId("_id");
            } catch (Exception e) {
                session.abortTransaction();
                throw new RuntimeException("Order creation failed", e);
            }
        }
    }
}
```

**调用示例**：

```java
List<Document> productOrders = Arrays.asList(
    new Document("productId", new ObjectId("507f1f77bcf86cd799439011")).append("quantity", 2),
    new Document("productId", new ObjectId("507f1f77bcf86cd799439012")).append("quantity", 1)
);
ObjectId userId = new ObjectId("507f1f77bcf86cd799439013");
ObjectId orderId = OrderService.createOrder(client, userId, productOrders);
```

### 3. 业务场景：查询用户订单历史

查询某用户的所有订单及其商品详情。

```java
import com.mongodb.client.*;
import com.mongodb.client.model.Aggregates;
import org.bson.Document;
import org.bson.types.ObjectId;
import java.util.Arrays;

public class OrderService {
    public static List<Document> getUserOrderHistory(MongoClient client, ObjectId userId) {
        MongoDatabase db = client.getDatabase("shop");
        MongoCollection<Document> ordersCollection = db.getCollection("orders");

        List<Document> orders = ordersCollection.aggregate(Arrays.asList(
                Aggregates.match(new Document("userId", userId)),
                Aggregates.lookup("products", "products.productId", "_id", "productDetails"),
                Aggregates.sort(new Document("createdAt", -1))
        )).into(new ArrayList<>());

        System.out.println("User order history: " + orders);
        return orders;
    }
}
```

### 4. 业务场景：取消订单并恢复库存

取消订单并将库存加回。

```java
import com.mongodb.client.*;
import com.mongodb.client.model.Updates;
import org.bson.Document;
import org.bson.types.ObjectId;
import static com.mongodb.client.model.Filters.eq;

public class OrderService {
    public static void cancelOrder(MongoClient client, ObjectId orderId) {
        MongoDatabase db = client.getDatabase("shop");
        MongoCollection<Document> ordersCollection = db.getCollection("orders");
        MongoCollection<Document> productsCollection = db.getCollection("products");

        try (ClientSession session = client.startSession()) {
            session.startTransaction();
            try {
                Document order = ordersCollection.find(eq("_id", orderId)).first();
                if (order == null || !order.getString("status").equals("pending")) {
                    throw new RuntimeException("Order not found or not cancellable");
                }

                // 恢复库存
                List<Document> products = order.getList("products", Document.class);
                for (Document productOrder : products) {
                    ObjectId productId = productOrder.getObjectId("productId");
                    Integer quantity = productOrder.getInteger("quantity");
                    productsCollection.updateOne(
                            session,
                            eq("_id", productId),
                            Updates.combine(
                                    Updates.inc("stock", quantity),
                                    Updates.set("updatedAt", new java.util.Date())
                            )
                    );
                }

                // 更新订单状态
                ordersCollection.updateOne(
                        session,
                        eq("_id", orderId),
                        Updates.combine(
                                Updates.set("status", "cancelled"),
                                Updates.set("updatedAt", new java.util.Date())
                        )
                );

                session.commitTransaction();
                System.out.println("Order " + orderId + " cancelled");
            } catch (Exception e) {
                session.abortTransaction();
                throw new RuntimeException("Order cancellation failed", e);
            }
        }
    }
}
```

## 三、MongoDB 面试八股文解析

以下是面试官可能针对 MongoDB CRUD 操作的常见问题及详细解答，涵盖技术深度和实际应用，适用于 Java 开发环境。

### 1. MongoDB 的优缺点是什么？

**解答**：

**优点**：

- **灵活性**：文档模型支持嵌套结构，适合快速迭代的开发场景，如电商、社交媒体。
- **高性能**：支持内存映射和索引优化，适合高吞吐量读写操作。
- **水平扩展**：通过分片和副本集实现分布式部署。
- **查询丰富**：支持聚合管道、地理空间查询等。

**缺点**：

- **数据一致性**：默认配置下优先性能，可能导致数据不一致（需配置 Write Concern）。
- **事务开销**：多文档事务性能较低，适合低并发场景。
- **存储空间**：BSON 格式可能占用较多空间。
- **学习曲线**：聚合管道和分片配置对新手不友好。

**面试延伸**：如何选择 MongoDB 或关系型数据库？答：根据业务需求，如高并发、灵活 schema 选 MongoDB，强一致性、复杂关系选 RDBMS。

### 2. MongoDB 的索引如何工作？有哪些类型？

**解答**：

**工作原理**：
MongoDB 使用 B 树或 B+ 树索引加速查询，索引存储字段值和文档指针，减少全表扫描。

**索引类型**：

- **单字段索引**：`collection.createIndex(new Document("price", 1))`。
- **复合索引**：`collection.createIndex(new Document("category", 1).append("price", -1))`。
- **多键索引**：用于数组字段，如 `collection.createIndex(new Document("tags", 1))`。
- **地理空间索引**：支持位置查询，如 `2dsphere`。
- **文本索引**：支持全文搜索，如 `collection.createIndex(new Document("description", "text"))`。
- **哈希索引**：适合等值查询，不支持范围查询。

**注意事项**：

- 索引提高查询性能，但增加写入开销和存储空间。
- 使用 `explain()` 分析查询计划。
- 定期清理无用索引。

**面试延伸**：如何优化索引？答：分析查询模式、覆盖查询、避免过多索引。

### 3. MongoDB 的事务如何实现？局限性是什么？

**解答**：

**实现**：
MongoDB 4.0 起支持多文档事务，基于 WiredTiger 引擎，采用快照隔离。Java 示例：

```java
try (ClientSession session = client.startSession()) {
    session.startTransaction();
    try {
        MongoCollection<Document> collection = client.getDatabase("shop").getCollection("products");
        collection.updateOne(session, eq("_id", productId), Updates.inc("stock", -10));
        session.commitTransaction();
    } catch (Exception e) {
        session.abortTransaction();
        throw e;
    }
}
```

**局限性**：

- **性能开销**：事务涉及锁和日志，性能低于单文档操作。
- **时间限制**：默认超时 60 秒。
- **分片限制**：跨分片事务性能较低。
- **适用场景**：适合需要强一致性的场景，如库存管理。

**面试延伸**：如何优化事务？答：减少事务范围、优化索引、避免跨分片。

### 4. 如何设计 MongoDB 的 Schema 以优化性能？

**解答**：

- 嵌入 vs 引用

  ：

  - 嵌入：将相关数据嵌入同一文档，适合读多写少。
  - 引用：通过 `_id` 关联集合，适合频繁更新。

- **索引优化**：为查询字段创建索引，优先复合索引。

- **避免大文档**：文档大小限制 16MB，需拆分。

- **分片键**：选择高基数、均匀分布的字段。

- **聚合优化**：将 `$match` 和 `$sort` 放在管道开头。

**示例**（嵌入式设计）：

```java
Document order = new Document("userId", userId)
    .append("orderDetails", new Document("products", productList).append("totalPrice", totalPrice))
    .append("status", "pending");
```

**面试延伸**：如何处理 Schema 变更？答：使用版本控制字段、逐步迁移数据。

### 5. MongoDB 的聚合管道是什么？如何优化？

**解答**：

**聚合管道**：
用于多阶段数据处理，如过滤、排序、分组。

**Java 示例**（统计商品总销售额）：

```java
MongoCollection<Document> collection = db.getCollection("orders");
List<Document> result = collection.aggregate(Arrays.asList(
    Aggregates.unwind("$products"),
    Aggregates.lookup("products", "products.productId", "_id", "productDetails"),
    Aggregates.unwind("$productDetails"),
    Aggregates.match(eq("productDetails.category", "Electronics")),
    Aggregates.group("$productDetails.category",
        Accumulators.sum("totalSales", new Document("$multiply", Arrays.asList("$products.quantity", "$productDetails.price")))
)).into(new ArrayList<>());
```

**优化方法**：

- **提前过滤**：将 `$match` 放开头。
- **使用索引**：为 `$match` 和 `$sort` 创建索引。
- **限制输出**：使用 `$limit` 和 `$skip`。
- **精简字段**：使用 `$project`。

**面试延伸**：如何调试？答：逐阶段执行、用 `explain()` 分析性能。

### 6. MongoDB 的分片和副本集有什么区别？

**解答**：

**副本集**：

- 提供数据冗余和高可用性，主节点处理写入，副节点同步数据。
- 支持读写分离，自动故障转移。

**分片**：

- 将数据分布到多个分片，适合大数据量。
- 需要 `mongos` 路由器，分片键决定数据分布。

**区别**：

- 副本集注重高可用性，分片注重扩展性。
- 副本集全量复制，分片数据分片存储。

**面试延伸**：如何选择分片键？答：选择高基数字段，避免单调递增字段。

### 7. 如何处理 MongoDB 的并发问题？

**解答**：

- **文档级锁**：WiredTiger 支持文档级锁定。
- **事务**：保证原子性。
- **乐观并发控制**：使用版本字段。

**Java 示例**（乐观并发控制）：

```java
Document product = collection.find(eq("_id", productId)).first();
UpdateResult result = collection.updateOne(
    and(eq("_id", productId), eq("version", product.getInteger("version"))),
    Updates.combine(set("price", newPrice), inc("version", 1))
);
if (result.getMatchedCount() == 0) {
    throw new RuntimeException("Concurrent update detected");
}
```

**面试延伸**：如何避免死锁？答：减少事务范围、优化索引。

### 8. MongoDB 的备份和恢复策略有哪些？

**解答**：

**备份**：

- **mongodump**：逻辑备份，导出 BSON。
- **文件系统快照**：物理备份。
- **oplog**：增量备份。
- **云服务**：如 MongoDB Atlas 自动备份。

**恢复**：

- **mongorestore**：从备份文件恢复。
- **oplog 回放**：恢复到特定时间点。

**注意**：

- 定期测试备份。
- 加密备份文件。
- 使用隐藏节点备份。

**面试延伸**：零停机备份？答：使用副本集的隐藏节点或延迟节点。

## 四、总结

使用 Java 的 MongoDB 驱动实现 CRUD 操作简单高效，结合电商库存管理场景可以处理复杂业务逻辑。面试中，需掌握索引、事务、分片、聚合管道等核心概念，并结合 Java 代码示例展示实现能力。本教程和八股文解析希望能助你在 MongoDB 开发和面试中更进一步！