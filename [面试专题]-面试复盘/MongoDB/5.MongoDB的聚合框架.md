# MongoDB聚合操作API与Java SDK实战示例

## 聚合操作API与Java SDK对应关系

| 聚合操作符   | 描述            | Java SDK对应方法         | Java示例                                                     |
| ------------ | --------------- | ------------------------ | ------------------------------------------------------------ |
| `$match`     | 过滤文档        | `Aggregates.match()`     | `Aggregates.match(Filters.eq("status", "A"))`                |
| `$project`   | 选择/重命名字段 | `Aggregates.project()`   | `Aggregates.project(Projections.fields(Projections.include("name"), Projections.computed("total", new Document("$add", Arrays.asList("$price", "$fee")))))` |
| `$group`     | 分组计算        | `Aggregates.group()`     | `Aggregates.group("$cust_id", Accumulators.sum("total", "$amount"))` |
| `$sort`      | 排序结果        | `Aggregates.sort()`      | `Aggregates.sort(Sorts.descending("age"))`                   |
| `$limit`     | 限制返回数量    | `Aggregates.limit()`     | `Aggregates.limit(5)`                                        |
| `$skip`      | 跳过文档        | `Aggregates.skip()`      | `Aggregates.skip(10)`                                        |
| `$unwind`    | 展开数组        | `Aggregates.unwind()`    | `Aggregates.unwind("$tags")`                                 |
| `$lookup`    | 关联查询        | `Aggregates.lookup()`    | `Aggregates.lookup("orders", "_id", "cust_id", "orders")`    |
| `$addFields` | 添加字段        | `Aggregates.addFields()` | `Aggregates.addFields(new Field<>("total", new Document("$sum", "$scores")))` |
| `$count`     | 计数            | `Aggregates.count()`     | `Aggregates.count("total")`                                  |
| `$facet`     | 多管道聚合      | `Aggregates.facet()`     | `Aggregates.facet(new Facet("price", Aggregates.bucket(...)), new Facet("year", ...))` |
| `$bucket`    | 范围分组        | `Aggregates.bucket()`    | `Aggregates.bucket("$price", Arrays.asList(0, 100, 200), "Other", new BsonField("count", new Document("$sum", 1)))` |
| `$merge`     | 结果写入集合    | `Aggregates.merge()`     | `Aggregates.merge("report", new MergeOptions().uniqueIdentifier("_id").whenMatched(MergeOptions.WhenMatched.REPLACE))` |

## Java SDK实战示例

### 示例1：基本销售分析(Java实现)

```java
import com.mongodb.client.MongoClient;
import com.mongodb.client.MongoCollection;
import com.mongodb.client.MongoDatabase;
import com.mongodb.client.model.*;
import org.bson.Document;
import org.bson.conversions.Bson;
import java.util.Arrays;
import java.util.Date;

public class SalesAnalysis {
    public static void main(String[] args) {
        MongoClient client = MongoClients.create("mongodb://localhost:27017");
        MongoDatabase database = client.getDatabase("salesDB");
        MongoCollection<Document> orders = database.getCollection("orders");
        
        List<Bson> pipeline = Arrays.asList(
            Aggregates.match(Filters.gte("date", new Date(2023-1900, 0, 1))),
            Aggregates.unwind("$items"),
            Aggregates.group(
                "$customer_id",
                Accumulators.sum("totalSpent", new Document("$multiply", Arrays.asList("$items.price", "$items.quantity"))),
                Accumulators.avg("avgOrderValue", new Document("$multiply", Arrays.asList("$items.price", "$items.quantity"))),
                Accumulators.sum("orderCount", 1)
            ),
            Aggregates.sort(Sorts.descending("totalSpent")),
            Aggregates.limit(10),
            Aggregates.project(Projections.fields(
                Projections.computed("customerId", "$_id"),
                Projections.excludeId(),
                Projections.include("totalSpent"),
                Projections.computed("avgOrderValue", new Document("$round", Arrays.asList("$avgOrderValue", 2))),
                Projections.include("orderCount")
            ))
        );
        
        orders.aggregate(pipeline).forEach(document -> {
            System.out.println(document.toJson());
        });
        
        client.close();
    }
}
```

### 示例2：多集合关联查询(Java实现)

```java
import com.mongodb.client.MongoClient;
import com.mongodb.client.MongoCollection;
import com.mongodb.client.model.*;
import org.bson.Document;
import org.bson.conversions.Bson;
import java.util.Arrays;

public class UserOrderAnalysis {
    public static void main(String[] args) {
        MongoClient client = MongoClients.create("mongodb://localhost:27017");
        MongoDatabase database = client.getDatabase("ecommerce");
        MongoCollection<Document> users = database.getCollection("users");
        
        List<Bson> pipeline = Arrays.asList(
            Aggregates.match(Filters.eq("status", "active")),
            Aggregates.lookup("orders", "_id", "user_id", "orders"),
            Aggregates.unwind("$orders", new UnwindOptions().preserveNullAndEmptyArrays(true)),
            Aggregates.group("$_id",
                Accumulators.first("name", "$name"),
                Accumulators.first("email", "$email"),
                Accumulators.sum("totalOrders", 
                    new Document("$cond", Arrays.asList(
                        new Document("$ifNull", Arrays.asList("$orders", false)), 
                        1, 
                        0
                    ))
                ),
                Accumulators.sum("totalSpent", "$orders.total")
            ),
            Aggregates.match(Filters.gt("totalOrders", 0)),
            Aggregates.sort(Sorts.descending("totalSpent"))
        );
        
        users.aggregate(pipeline).forEach(document -> {
            System.out.println(document.toJson());
        });
        
        client.close();
    }
}
```

### 示例3：时间序列分析(Java实现)

```java
import com.mongodb.client.MongoClient;
import com.mongodb.client.MongoCollection;
import com.mongodb.client.model.*;
import org.bson.Document;
import org.bson.conversions.Bson;
import java.util.Arrays;
import java.util.Date;

public class TimeSeriesAnalysis {
    public static void main(String[] args) {
        MongoClient client = MongoClients.create("mongodb://localhost:27017");
        MongoDatabase database = client.getDatabase("salesDB");
        MongoCollection<Document> sales = database.getCollection("sales");
        
        List<Bson> pipeline = Arrays.asList(
            Aggregates.match(Filters.and(
                Filters.gte("date", new Date(2023-1900, 0, 1)),
                Filters.lt("date", new Date(2024-1900, 0, 1))
            )),
            Aggregates.project(Projections.fields(
                Projections.computed("yearMonthDay", 
                    new Document("$dateToString", 
                        new Document("format", "%Y-%m-%d")
                            .append("date", "$date")
                    )
                ),
                Projections.include("product", "amount")
            )),
            Aggregates.group(
                new Document("date", "$yearMonthDay")
                    .append("product", "$product"),
                Accumulators.sum("totalAmount", "$amount"),
                Accumulators.sum("count", 1)
            ),
            Aggregates.sort(Sorts.orderBy(
                Sorts.ascending("_id.date"),
                Sorts.descending("totalAmount")
            )),
            Aggregates.group("$_id.date",
                Accumulators.first("topProduct", "$_id.product"),
                Accumulators.first("topAmount", "$totalAmount"),
                Accumulators.sum("dailyTotal", "$totalAmount")
            ),
            Aggregates.project(Projections.fields(
                Projections.computed("date", "$_id"),
                Projections.include("topProduct", "topAmount", "dailyTotal"),
                Projections.computed("percentage", 
                    new Document("$multiply", 
                        Arrays.asList(
                            new Document("$divide", Arrays.asList("$topAmount", "$dailyTotal")),
                            100
                        )
                    )
                )
            ))
        );
        
        sales.aggregate(pipeline).forEach(document -> {
            System.out.println(document.toJson());
        });
        
        client.close();
    }
}
```

### 示例4：使用$merge写入结果(Java实现)

```java
import com.mongodb.client.MongoClient;
import com.mongodb.client.MongoCollection;
import com.mongodb.client.model.*;
import org.bson.Document;
import org.bson.conversions.Bson;
import java.util.Arrays;
import java.util.Date;

public class MergeExample {
    public static void main(String[] args) {
        MongoClient client = MongoClients.create("mongodb://localhost:27017");
        MongoDatabase database = client.getDatabase("salesDB");
        MongoCollection<Document> sales = database.getCollection("sales");
        
        List<Bson> pipeline = Arrays.asList(
            Aggregates.match(Filters.gte("date", new Date(2023-1900, 0, 1))),
            Aggregates.group(
                new Document("product", "$product")
                    .append("month", new Document("$month", "$date")),
                Accumulators.sum("totalSales", "$amount"),
                Accumulators.avg("avgPrice", "$price")
            ),
            Aggregates.sort(Sorts.orderBy(
                Sorts.ascending("_id.month"),
                Sorts.descending("totalSales")
            )),
            Aggregates.merge("monthly_product_reports", 
                new MergeOptions()
                    .uniqueIdentifier("_id")
                    .whenMatched(MergeOptions.WhenMatched.REPLACE)
                    .whenNotMatched(MergeOptions.WhenNotMatched.INSERT)
            )
        );
        
        sales.aggregate(pipeline).forEach(document -> {
            // $merge阶段不会返回文档，这里只是为了演示
            System.out.println("Processed: " + document);
        });
        
        client.close();
    }
}
```

## 最佳实践

1. **使用类型安全构建器**：尽可能使用`Filters`、`Projections`、`Sorts`等构建器，而不是原始`Document`对象
2. **管道优化**：将`$match`和`$project`放在管道前面，减少后续处理的数据量
3. **索引利用**：确保聚合管道中的`$match`和`$sort`操作使用了适当的索引
4. **内存限制**：对于大数据集，考虑使用`$limit`和`$skip`或`allowDiskUse(true)`选项
5. **错误处理**：添加适当的try-catch块处理可能出现的异常

```java
try {
    collection.aggregate(pipeline)
        .allowDiskUse(true)
        .forEach(document -> {
            // 处理结果
        });
} catch (MongoException e) {
    System.err.println("聚合查询失败: " + e.getMessage());
}
```