# Elasticsearch 常数分数查询与函数分数查询的深度剖析及电商场景应用

在 Elasticsearch 的查询体系中，复合查询（Compound Queries）是实现复杂搜索逻辑的基石，其中 **Constant Score Query** 和 **Function Score Query** 是两种关键工具。本文将以模拟面试官的视角，深入剖析这两者的根本差异，并通过具体场景说明哪些业务需求只有它们才能胜任，尤其是在电商场景中对相关性算分、召回率和精确率的影响。

------

## 一、Constant Score Query 与 Function Score Query 的根本差异

### 1. Constant Score Query：固定分数的“过滤器”

**核心理念**：Constant Score Query 将子查询的结果赋予一个固定的分数（默认 1.0，可通过 `boost` 参数调整），完全忽略子查询的原始相关性得分。它的本质是一个高效的过滤器，运行在过滤上下文（filter context）中，旨在快速筛选文档而不进行复杂相关性计算。

**技术特点**：

- **分数计算**：所有匹配文档的分数固定为 `boost` 值，无视关键词匹配度、TF-IDF 等传统相关性因子。
- **性能**：极高，因为无需计算动态得分，适合大规模数据集的过滤。
- **适用场景**：需要“全或无”逻辑的场景，即只关心文档是否匹配条件，而不关心匹配程度。

**代码示例**（筛选特定品类的促销商品）：

```java
SearchRequest searchRequest = new SearchRequest("products");
SearchSourceBuilder searchSourceBuilder = new SearchSourceBuilder();
ConstantScoreQueryBuilder constantScoreQuery = QueryBuilders.constantScoreQuery(
    QueryBuilders.termQuery("category", "electronics")
).boost(2.0f);
searchSourceBuilder.query(constantScoreQuery);
searchRequest.source(searchSourceBuilder);
```

------

### 2. Function Score Query：动态分数的“排序优化器”

**核心理念**：Function Score Query 通过自定义函数（如 `weight`、`field_value_factor`、`script_score`）动态调整查询结果的相关性得分，允许开发者根据业务需求灵活控制排序。它的本质是增强查询的排序能力，适合需要个性化或动态排序的场景。

**技术特点**：

- **分数计算**：基于子查询的原始得分，结合自定义函数（如字段值、脚本或随机因子）计算最终得分。
- **性能**：相对较低，因为需要执行函数计算，特别是在使用复杂脚本时。
- **适用场景**：需要根据业务逻辑（如价格、销量、用户偏好）动态调整文档排序的场景。

**代码示例**（基于销量调整手机搜索结果排序）：

```java
SearchRequest searchRequest = new SearchRequest("products");
SearchSourceBuilder searchSourceBuilder = new SearchSourceBuilder();
FunctionScoreQueryBuilder functionScoreQuery = QueryBuilders.functionScoreQuery(
    QueryBuilders.matchQuery("name", "phone"),
    new FunctionScoreQueryBuilder.FilterFunctionBuilder[]{
        new FunctionScoreQueryBuilder.FilterFunctionBuilder(
            QueryBuilders.termQuery("brand", "Apple"),
            ScoreFunctionBuilders.fieldValueFactorFunction("sales").factor(0.01f)
        )
    }
).boostMode(CombineFunction.MULTIPLY);
searchSourceBuilder.query(functionScoreQuery);
searchRequest.source(searchSourceBuilder);
```

------

### 3. 根本差异（面试官视角）

**面试官提问**：Constant Score Query 和 Function Score Query 的本质区别是什么？在哪些场景下，只有一种查询能胜任，而其他查询（包括 Bool Query）无法替代？

**回答**：

- **分数计算的本质**：
  - **Constant Score Query**：完全抛弃相关性得分，强制所有匹配文档获得固定分数。它不关心文档的匹配程度（如关键词频率或字段权重），只关心是否匹配。
  - **Function Score Query**：基于子查询的原始得分，通过函数动态调整，允许开发者根据业务逻辑（如字段值、脚本）精细控制排序。
  - **差异**：Constant Score Query 是“静态”分数，适合“过滤优先”的场景；Function Score Query 是“动态”分数，适合“排序优化”的场景。
- **性能差异**：
  - **Constant Score Query**：运行在过滤上下文，性能极高，适合大规模数据筛选。
  - **Function Score Query**：涉及函数计算，性能开销较大，尤其在复杂脚本或多字段计算时。
- **查询逻辑的灵活性**：
  - **Constant Score Query**：逻辑简单，适合单一条件的严格过滤。
  - **Function Score Query**：逻辑复杂，支持多维度、动态的得分调整。

**面试官追问**：能否举例说明，只有 Constant Score Query 或 Function Score Query 才能胜任的场景？

------

## 二、只有 Constant Score Query 才能胜任的场景

### 场景 1：电商促销活动中快速筛选特定品类商品

**需求**：在“双11”促销活动中，电商平台需展示所有“电子产品”类别的商品，且所有商品以固定分数排序（后续可能按价格或库存排序），不考虑关键词匹配度。

**为什么只有 Constant Score Query 能胜任？**

- **固定分数需求**：促销活动中，所有符合条件的商品（如 `category=electronics`）需要同等曝光机会，传统相关性得分（如 TF-IDF）会导致某些商品因关键词频率被错误排序，影响公平性。
- **性能要求**：促销页面需要快速响应，涉及数百万商品的筛选，Constant Score Query 的过滤上下文避免了复杂得分计算，性能最佳。
- **Bool Query 的局限性**：虽然 Bool Query 的 `filter` 也能筛选，但无法保证固定分数，可能导致后续排序逻辑复杂化。
- **Function Score Query 的局限性**：Function Score Query 会引入不必要的函数计算，增加性能开销，且无法完全抛弃原始得分。

**代码实现**：

```java
SearchRequest searchRequest = new SearchRequest("products");
SearchSourceBuilder searchSourceBuilder = new SearchSourceBuilder();
ConstantScoreQueryBuilder constantScoreQuery = QueryBuilders.constantScoreQuery(
    QueryBuilders.boolQuery()
        .filter(QueryBuilders.termQuery("category", "electronics"))
        .filter(QueryBuilders.termQuery("is_promotion", true))
).boost(1.0f);
searchSourceBuilder.query(constantScoreQuery);
searchRequest.source(searchSourceBuilder);
```

**效果**：

- **召回率**：确保所有电子类促销商品被召回，100% 覆盖。
- **精确率**：通过严格的过滤条件（类别 + 促销状态），排除无关商品。
- **意义**：快速筛选出促销商品，保证公平排序，适合高并发场景。

------

### 场景 2：法律合规性过滤

**需求**：在某些地区，电商平台需严格过滤掉不符合法规的商品（如禁售品），并确保这些商品在结果中完全不出现，且匹配商品分数统一。

**为什么只有 Constant Score Query 能胜任？**

- **强制过滤**：Constant Score Query 确保所有合规商品被赋予固定分数，非合规商品完全被排除，无需相关性排序。
- **性能优先**：法规过滤通常涉及大量文档，Constant Score Query 的高效过滤上下文是最佳选择。
- **Bool Query 的局限性**：Bool Query 的 `must_not` 可以排除禁售品，但无法保证固定分数，可能导致后续处理复杂。
- **Function Score Query 的局限性**：引入动态分数计算无意义，且增加不必要的性能开销。

**代码实现**：

```java
SearchRequest searchRequest = new SearchRequest("products");
SearchSourceBuilder searchSourceBuilder = new SearchSourceBuilder();
ConstantScoreQueryBuilder constantScoreQuery = QueryBuilders.constantScoreQuery(
    QueryBuilders.boolQuery()
        .mustNot(QueryBuilders.termQuery("is_banned", true))
).boost(1.0f);
searchSourceBuilder.query(constantScoreQuery);
searchRequest.source(searchSourceBuilder);
```

**效果**：

- **召回率**：确保所有合规商品被召回。
- **精确率**：严格排除禁售品，提升结果合规性。
- **意义**：满足法律合规性要求，简化后续排序逻辑。

------

## 三、只有 Function Score Query 才能胜任的场景

### 场景 1：个性化推荐基于用户行为动态排序

**需求**：电商平台搜索“手机”时，需根据用户历史行为（如偏好高价商品或热销商品）动态调整排序，例如优先展示高销量或高评分的 Apple 手机。

**为什么只有 Function Score Query 能胜任？**

- **动态分数调整**：Function Score Query 允许基于字段（如 `sales`、`rating`）或脚本动态计算分数，满足个性化需求。其他查询（如 Bool Query 或 Constant Score Query）无法根据外部变量（如用户行为）调整得分。
- **复杂排序逻辑**：通过 `field_value_factor` 或 `script_score`，可以结合多种业务因子（如销量、评分、库存）优化排序。
- **Constant Score Query 的局限性**：固定分数无法实现动态排序，丢失个性化能力。
- **Bool Query 的局限性**：Bool Query 仅能控制匹配逻辑，无法基于字段值或脚本调整得分。

**代码实现**：

```java
SearchRequest searchRequest = new SearchRequest("products");
SearchSourceBuilder searchSourceBuilder = new SearchSourceBuilder();

// 构建FunctionScoreQuery，用于对基础查询结果进行加权评分
FunctionScoreQueryBuilder functionScoreQuery = QueryBuilders.functionScoreQuery(
    // 基础查询：匹配商品名称包含"phone"的文档（基础分由BM25算法自动计算）
    QueryBuilders.matchQuery("name", "phone"),

    // 定义两个加权函数（均针对Apple品牌商品）：
    new FunctionScoreQueryBuilder.FilterFunctionBuilder[]{
        // 函数1：用sales字段加权（sales值*0.01）
        new FunctionScoreQueryBuilder.FilterFunctionBuilder(
            QueryBuilders.termQuery("brand", "Apple"), // 仅对Apple品牌生效
            ScoreFunctionBuilders.fieldValueFactorFunction("sales")
                .factor(0.01f)    // 加权系数：0.01（表示每增加1个销量，分数+0.01）
                .missing(0)       // 如果sales字段不存在，默认值为0
        ),
        
        // 函数2：用rating字段加权（rating值*0.1）
        new FunctionScoreQueryBuilder.FilterFunctionBuilder(
            QueryBuilders.termQuery("brand", "Apple"), // 同样仅对Apple品牌生效
            ScoreFunctionBuilders.fieldValueFactorFunction("rating")
                .factor(0.1f)     // 加权系数：0.1（表示每增加1分评分，分数+0.1）
                .missing(0)       // 如果rating字段不存在，默认值为0
        )
    }
).boostMode(CombineFunction.SUM); // 加权方式：函数分与基础分相加（SUM）

searchSourceBuilder.query(functionScoreQuery);
searchRequest.source(searchSourceBuilder);

/* 
 * 评分逻辑详解：
 * 
 * 1. 基础分（原始相关性得分）：
 *    - 由matchQuery("name", "phone")通过BM25算法计算得出
 *    - 表示文档与"phone"关键词的匹配程度（纯文本相关性）
 * 
 * 2. 函数加权分（针对Apple品牌）：
 *    - sales加权分 = sales字段值 * 0.01（系数较小，影响较弱）
 *    - rating加权分 = rating字段值 * 0.1（系数较大，影响更强）
 *    - 最终函数分 = sales加权分 + rating加权分（因为boostMode=SUM）
 * 
 * 3. 总分计算：
 *    - 非Apple品牌：总分 = 基础分（无额外加权）
 *    - Apple品牌：总分 = 基础分 + (sales*0.01 + rating*0.1)
 * 
 * 系数差异的意义：
 * - rating的0.1 > sales的0.01，表示：
 *   - 评分（rating）对排序的影响权重是销量（sales）的10倍
 *   - 例如：rating=5分相当于sales=50的加分效果
 */
```

**效果**：

- **召回率**：通过子查询确保所有相关手机被召回。
- **精确率**：通过销量和评分的动态加权，优先展示用户更可能感兴趣的商品。
- **意义**：提升点击率和转化率，增强个性化推荐效果。

------

### 场景 2：促销活动中基于库存和折扣动态排序

**需求**：在促销活动中，搜索“电子产品”时，需优先展示库存充足且折扣力度大的商品，同时考虑关键词相关性。

**为什么只有 Function Score Query 能胜任？**

- **多维度分数计算**：Function Score Query 支持通过脚本或字段值（如 `inventory`、`discount`）综合计算分数，满足复杂排序需求。
- **动态性**：促销活动的折扣和库存可能实时变化，Function Score Query 的 `script_score` 可动态引入外部变量。
- **Constant Score Query 的局限性**：固定分数无法根据库存或折扣调整排序。
- **Bool Query 的局限性**：无法实现基于字段值的动态排序。

**代码实现**：

```java
SearchRequest searchRequest = new SearchRequest("products");
SearchSourceBuilder searchSourceBuilder = new SearchSourceBuilder();
FunctionScoreQueryBuilder functionScoreQuery = QueryBuilders.functionScoreQuery(
    QueryBuilders.matchQuery("category", "electronics"),
    new FunctionScoreQueryBuilder.FilterFunctionBuilder[]{
        new FunctionScoreQueryBuilder.FilterFunctionBuilder(
            ScoreFunctionBuilders.scriptScoreFunction(
                ScriptBuilders.script("doc['inventory'].value * params.discount_factor")
                    .params(Collections.singletonMap("discount_factor", 0.1))
            )
        )
    }
).boostMode(CombineFunction.MULTIPLY);
searchSourceBuilder.query(functionScoreQuery);
searchRequest.source(searchSourceBuilder);
```

**效果**：

- **召回率**：确保所有电子产品被召回。
- **精确率**：通过库存和折扣的动态加权，优先展示高库存、高折扣商品。
- **意义**：优化促销活动效果，减少库存积压，提高用户购买意愿。

------

## 四、面试官视角：为什么其他查询无法替代？

**面试官提问**：为什么 Bool Query 不能完全替代 Constant Score Query 或 Function Score Query？

**回答**：

- **Bool Query 的局限性**：
  - Bool Query 擅长组合查询条件（`must`、`should`、`filter`、`must_not`），但无法直接控制分数。它的 `filter` 上下文虽能高效筛选，但无法赋予固定分数或动态调整分数。
  - 在需要固定分数的场景（如促销品类筛选），Bool Query 无法保证所有匹配文档分数一致。
  - 在需要动态排序的场景（如个性化推荐），Bool Query 无法基于字段值或脚本调整得分。
- **Constant Score Query 的独特性**：
  - 只有它能保证固定分数，适合需要公平排序或高性能过滤的场景（如法规合规性检查）。
  - 其他查询（包括 Bool Query）无法完全抛弃相关性得分。
- **Function Score Query 的独特性**：
  - 只有它能通过函数动态调整分数，适合个性化或多维度排序场景（如基于销量、库存的推荐）。
  - 其他查询无法实现基于字段值或脚本的动态得分计算。

------

## 五、电商场景中的作用与意义

### 1. Constant Score Query

- 作用

  ：

  - **高召回率**：确保所有符合条件的商品（如促销品类）被召回，适合“广撒网”场景。
  - **高精确率**：通过严格过滤条件，排除无关商品。
  - **性能优化**：在高并发场景（如促销活动）中，快速返回结果。

- **意义**：简化排序逻辑，满足公平性要求，适用于促销页面、合规性过滤等场景。

### 2. Function Score Query

- 作用

  ：

  - **动态排序**：根据业务需求（如销量、评分、库存）优化结果排序，提升用户体验。
  - **高精确率**：通过个性化得分计算，优先展示用户更感兴趣的商品。
  - **灵活性**：支持复杂业务逻辑（如结合用户行为、实时库存）。

- **意义**：增强个性化推荐效果，提高点击率和转化率，适合搜索结果优化和促销活动。

------

## 六、总结

**Constant Score Query** 和 **Function Score Query** 在 Elasticsearch 中各有不可替代的角色：

- **Constant Score Query**：以固定分数和高效过滤为核心，独适合需要高召回率和公平排序的场景，如促销品类筛选或法规合规性检查。

- **Function Score Query**：以动态分数计算为核心，独适合需要个性化排序和精确率优化的场景，如基于用户行为的推荐或促销商品排序。

- 电商场景中的价值

  ：

  - Constant Score Query 确保所有相关商品被快速召回，适合高并发、公平性要求高的场景。
  - Function Score Query 通过动态排序提升用户体验，适合个性化推荐和复杂业务逻辑。

在实际开发中，开发者应根据业务需求选择合适的查询工具，并结合 Bool Query 构建复杂逻辑，以实现召回率、精确率和性能的平衡。未来，可进一步探索 Function Score Query 的脚本功能或结合机器学习模型（如 LTR）优化搜索效果。