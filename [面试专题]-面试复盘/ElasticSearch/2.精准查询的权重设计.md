# Elasticsearch 精准查询（term 和 range）的权重设计在电商场景中的应用

在电商搜索场景中，精准查询（如 `term` 和 `range` 查询）是确保搜索结果高度相关的重要工具，尤其在处理商品（`item` 或 `items`）的精确匹配和范围过滤时。权重设计通过调整文档得分（`_score`）优化结果排序，直接影响用户体验和业务转化。本文将基于 `RestHighLevelClient`，结合电商的 SPU（标准化产品单元）和 SKU（库存量单位），详细讲解 `term` 和 `range` 查询的权重设计，涵盖权重分配原则、间隔控制（针对 `match_phrase` 的结合使用）、实现代码及优化策略，并通过模拟面试官的“拷打”环节深入剖析。

## 1. 背景：精准查询与电商场景

### 1.1 精准查询的定义

精准查询要求查询条件与文档字段内容完全或高度匹配，主要包括：

- **`term` 查询**：对 `keyword` 类型字段进行精确匹配，不进行分词。适用于匹配商品 ID、品牌、类别等固定值。
- **`range` 查询**：匹配数值或日期范围，适用于过滤价格、库存、上架时间等。例如，搜索价格在 5000-8000 元的商品。
- **结合全文搜索**：在电商场景中，精准查询常与全文搜索（如 `match` 或 `match_phrase`）结合使用，以平衡召回率和精确率。

### 1.2 电商场景中的 `item` 和 `items`

在电商平台中，`item` 或 `items` 通常指商品文档，可能包含：

- **SPU**：如“iPhone 13”，包含名称（`spu_name`）、描述（`spu_description`）、品牌（`brand`）等。
- **SKU**：如“iPhone 13 128GB 星光色”，包含规格（`sku_attributes`）、价格（`price`）、库存（`stock`）等。

用户搜索可能涉及：

- 精确匹配：如搜索“iPhone 13”（`term` 查询 `spu_name.keyword`）。
- 范围过滤：如搜索价格在 5000-8000 元的手机（`range` 查询 `price`）。
- 全文搜索：如搜索“苹果手机 128GB”（`match` 或 `match_phrase`）。

### 1.3 权重设计目标

权重设计的目标是通过调整文档得分，确保：

- **相关性优先**：精确匹配（如 `spu_name` 或 `brand`）的文档排名靠前。
- **业务需求**：如优先展示高库存或促销商品。
- **用户体验**：结果排序符合用户意图，例如搜索“iPhone 13”时，精确匹配的 SPU 优先于模糊匹配的描述。

## 2. 权重设计的影响因素

### 2.1 字段重要性

不同字段对搜索结果的相关性贡献不同：

- **SPU 名称（spu_name）**：用户搜索的核心字段，精确匹配（如 `term` 查询 `spu_name.keyword`）应赋予高权重。
- **SKU 属性（sku_attributes）**：规格信息（如“128GB”）次重要，精准匹配权重略低于 SPU 名称。
- **品牌（brand）**：精确匹配品牌（如 `term` 查询 `brand.keyword`）权重适中。
- **价格（price）/库存（stock）**：`range` 查询用于过滤，权重通过业务规则调整。
- **SPU 描述（spu_description）**：全文搜索字段，权重最低。

### 2.2 查询类型特性

- **`term` 查询**：完全匹配 `keyword` 字段，适合 SPU 名称、品牌等固定值。得分固定（默认 `_score=1.0`），需通过 `boost` 调整。
- **`range` 查询**：通常在 `filter` 上下文中使用，得分不直接影响排序，但在 `function_score` 中可通过业务规则加权。
- **结合 `match_phrase`**：当精准查询与全文搜索结合时，`match_phrase` 的 `slop` 参数影响匹配灵活性，权重需协调。

### 2.3 用户意图与业务需求

- **用户意图**：搜索“iPhone 13”时，期望精确匹配 SPU 名称；搜索“手机 5000到8000元”时，需结合 `range` 查询过滤价格。
- **业务需求**：如优先展示库存充足或促销商品，可通过 `function_score` 增加权重。

## 3. 权重设计的实现方法

以下是基于 `RestHighLevelClient` 的 `term` 和 `range` 查询权重设计示例，结合电商场景。

### 3.1 使用 `term` 查询与 `boost`

`term` 查询适合精确匹配 `keyword` 字段，通过 `boost` 调整权重：

```java
import org.elasticsearch.action.search.SearchRequest;
import org.elasticsearch.action.search.SearchResponse;
import org.elasticsearch.client.RequestOptions;
import org.elasticsearch.index.query.QueryBuilders;
import org.elasticsearch.search.builder.SearchSourceBuilder;

public class TermQueryWeightExample {
    public static void main(String[] args) throws Exception {
        RestHighLevelClient client = ElasticsearchClient.getClient();
        
        SearchRequest searchRequest = new SearchRequest("products");
        SearchSourceBuilder sourceBuilder = new SearchSourceBuilder();
        
        BoolQueryBuilder boolQuery = QueryBuilders.boolQuery();
        
        // 精确匹配 SPU 名称
        boolQuery.should(QueryBuilders.termQuery("spu_name.keyword", "iPhone 13").boost(5.0f));
        
        // 精确匹配品牌
        boolQuery.should(QueryBuilders.termQuery("brand.keyword", "Apple").boost(3.0f));
        
        // 精确匹配 SKU 属性
        boolQuery.should(QueryBuilders.termQuery("sku_attributes.keyword", "128GB 星光色").boost(2.0f));
        
        sourceBuilder.query(boolQuery);
        searchRequest.source(sourceBuilder);
        
        SearchResponse response = client.search(searchRequest, RequestOptions.DEFAULT);
        response.getHits().forEach(hit -> {
            System.out.println(hit.getSourceAsString() + ", Score: " + hit.getScore());
        });
        
        client.close();
    }
}
```

**权重设计逻辑**：

- `spu_name.keyword`：`boost=5.0`，精确匹配商品名称优先级最高。
- `brand.keyword`：`boost=3.0`，品牌匹配次之。
- `sku_attributes.keyword`：`boost=2.0`，规格匹配作为补充。

### 3.2 使用 `range` 查询与 `function_score`

`range` 查询通常在 `filter` 上下文中使用，不直接影响得分。通过 `function_score` 结合业务规则调整权重，例如优先高库存商品：

```java
SearchSourceBuilder sourceBuilder = new SearchSourceBuilder();
FunctionScoreQueryBuilder functionScoreQuery = QueryBuilders.functionScoreQuery(
    QueryBuilders.boolQuery()
        .must(QueryBuilders.termQuery("spu_name.keyword", "iPhone 13").boost(5.0f))
        .filter(QueryBuilders.rangeQuery("price").gte(5000).lte(8000)),
    new FunctionScoreQueryBuilder.FilterFunctionBuilder[] {
        new FunctionScoreQueryBuilder.FilterFunctionBuilder(
            QueryBuilders.rangeQuery("stock").gt(100),
            ScoreFunctionBuilders.weightFactorFunction(2.0f)
        )
    }
).boostMode(CombineFunction.MULTIPLY);

sourceBuilder.query(functionScoreQuery);
```

**权重设计逻辑**：

- `term` 查询确保 SPU 名称精确匹配，`boost=5.0`。
- `range` 查询过滤价格范围（5000-8000 元）。
- `function_score` 为库存大于 100 的商品增加 2.0 倍权重，提升业务优先级。

### 3.3 结合 `match_phrase` 与 `slop`

为提高召回率，精准查询常与 `match_phrase` 结合，`slop` 参数控制短语匹配的间隔：

```java
BoolQueryBuilder boolQuery = QueryBuilders.boolQuery();

// 过滤价格范围
boolQuery.filter(QueryBuilders.rangeQuery("price").gte(5000).lte(8000));

// 精确匹配 SPU 名称
boolQuery.should(QueryBuilders.termQuery("spu_name.keyword", "iPhone 13").boost(5.0f));

// 短语匹配 SPU 名称（允许间隔）
boolQuery.should(QueryBuilders.matchPhraseQuery("spu_name", "iPhone 128GB").slop(1).boost(4.0f));

// 精确匹配 SKU 属性
boolQuery.should(QueryBuilders.termQuery("sku_attributes.keyword", "128GB 星光色").boost(2.0f));

sourceBuilder.query(boolQuery);
```

**权重设计逻辑**：

- `term` 查询 `spu_name.keyword`：最高权重（5.0），确保完全匹配优先。
- `match_phrase` 查询 `spu_name`：`slop=1` 允许插入词（如“iPhone 13 128GB”），权重略低（4.0）。
- `term` 查询 `sku_attributes.keyword`：权重 2.0，补充规格匹配。
- `range` 查询 `price`：作为过滤条件，确保结果在用户指定范围内。

## 4. 权重设计的优化策略

### 4.1 字段权重分配

- **核心字段高权重**：`spu_name.keyword` 和 `spu_name`（`match_phrase`）权重最高（4.0-5.0），反映用户对商品名称的关注。
- **次要字段适中权重**：`brand.keyword` 和 `sku_attributes.keyword` 权重次之（2.0-3.0）。
- **补充字段低权重**：如 `spu_description`（若结合全文搜索，权重设为 1.0）。

### 4.2 动态权重调整

结合业务规则动态调整权重，例如：

- **库存优先**：通过 `function_score` 为高库存商品加权。
- **促销商品**：为促销商品添加额外权重：

```java
FunctionScoreQueryBuilder functionScoreQuery = QueryBuilders.functionScoreQuery(
    QueryBuilders.termQuery("spu_name.keyword", "iPhone 13"),
    new FunctionScoreQueryBuilder.FilterFunctionBuilder[] {
        new FunctionScoreQueryBuilder.FilterFunctionBuilder(
            QueryBuilders.termQuery("is_promotion", true),
            ScoreFunctionBuilders.weightFactorFunction(1.5f)
        )
    }
);
```

### 4.3 间隔控制（slop 参数）

在结合 `match_phrase` 时，`slop` 参数影响精准查询的灵活性：

- **slop=0**：严格短语匹配，精确度高，召回率低。
- **slop=1**：允许一个词的间隔（如“iPhone 128GB”匹配“iPhone 13 128GB”），平衡精确度和召回率。
- **选择原则**：电商场景中，`slop=0` 或 `1` 适合商品名称和规格匹配，避免过多噪音。

### 4.4 分词与 `keyword` 类型配合

- **keyword 类型**：`term` 查询用于 `spu_name.keyword` 等字段，确保完全匹配。
- **text 类型**：结合 `match_phrase` 查询，配合 `ik_smart` 分词器，处理中文短语。
- **索引映射**：

```json
PUT products
{
  "mappings": {
    "properties": {
      "spu_name": {
        "type": "text",
        "analyzer": "ik_smart",
        "fields": {
          "keyword": {
            "type": "keyword"
          }
        }
      },
      "sku_attributes": {
        "type": "text",
        "analyzer": "ik_smart",
        "fields": {
          "keyword": {
            "type": "keyword"
          }
        }
      },
      "price": {
        "type": "float"
      },
      "stock": {
        "type": "integer"
      }
    }
  }
}
```

### 4.5 A/B 测试与监控

- **A/B 测试**：比较不同权重配置（如 `spu_name^5` vs `spu_name^4`）对点击率和转化率的影响。
- **Explain API**：分析文档得分，排查权重不合理问题：

```java
sourceBuilder.explain(true);
```

- **用户行为**：通过点击和购买数据优化权重分配。

## 5. 面试官“拷打”环节：权重设计相关问题

以下是模拟面试官可能提出的问题及解答：

### Q1：为什么 `term` 查询需要权重设计？如何确定 `boost` 值？

**答**：
`term` 查询默认得分为 1.0，不考虑字段长度或词频，需通过 `boost` 调整以反映字段重要性。  

- 确定 `boost` 值

  ：  

  - 根据字段优先级：`spu_name.keyword`（5.0）> `brand.keyword`（3.0）> `sku_attributes.keyword`（2.0）。  
  - 结合用户意图：精确匹配商品名称优先于品牌或规格。  
  - 通过 A/B 测试：比较不同 `boost` 配置的点击率和转化率，优化权重。

- **实现示例**：

```java
boolQuery.should(QueryBuilders.termQuery("spu_name.keyword", "iPhone 13").boost(5.0f));
boolQuery.should(QueryBuilders.termQuery("brand.keyword", "Apple").boost(3.0f));
```

### Q2：`range` 查询如何影响权重设计？

**答**：
`range` 查询通常在 `filter` 上下文中使用，不直接影响得分，但在 `function_score` 中可通过业务规则加权。  

- **影响**：通过 `filter` 缩小结果集，结合 `function_score` 为特定范围（如高库存）加权。  
- **示例**：为价格 5000-8000 元且库存大于 100 的商品加权：

```java
FunctionScoreQueryBuilder functionScoreQuery = QueryBuilders.functionScoreQuery(
    QueryBuilders.termQuery("spu_name.keyword", "iPhone 13"),
    new FunctionScoreQueryBuilder.FilterFunctionBuilder[] {
        new FunctionScoreQueryBuilder.FilterFunctionBuilder(
            QueryBuilders.rangeQuery("stock").gt(100),
            ScoreFunctionBuilders.weightFactorFunction(2.0f)
        )
    }
);
```

- **优化**：根据业务需求（如促销、库存）调整 `weightFactorFunction` 的值。

### Q3：如何协调 `term` 和 `match_phrase` 的权重？

**答**：  

- **`term` 查询**：用于 `keyword` 字段，完全匹配，权重较高（如 5.0），适合精确匹配商品名称。  
- **`match_phrase` 查询**：用于 `text` 字段，考虑分词和顺序，`slop` 增加灵活性，权重略低（如 4.0）。  
- **协调方法**：在 `bool` 查询中使用 `should` 组合，优先 `term` 查询，`match_phrase` 补充召回。  
- **示例**：

```java
boolQuery.should(QueryBuilders.termQuery("spu_name.keyword", "iPhone 13").boost(5.0f));
boolQuery.should(QueryBuilders.matchPhraseQuery("spu_name", "iPhone 13").slop(1).boost(4.0f));
```

### Q4：如果精准查询召回率过低，如何优化？

**答**：  

- **检查字段类型**：确保 `term` 查询使用 `keyword` 字段，`match_phrase` 使用 `text` 字段。  
- **调整 `slop`**：在 `match_phrase` 中设置 `slop=1` 或 `2`，增加短语匹配灵活性。  
- **补充全文搜索**：结合 `match` 查询，覆盖模糊匹配场景，权重设低（如 1.0）。  
- **同义词**：配置同义词（如“iPhone = 苹果”），提高召回率。  
- **示例**：

```java
boolQuery.should(QueryBuilders.termQuery("spu_name.keyword", "iPhone 13").boost(5.0f));
boolQuery.should(QueryBuilders.matchPhraseQuery("spu_name", "iPhone 13").slop(1).boost(4.0f));
boolQuery.should(QueryBuilders.matchQuery("spu_description", "iPhone 13").boost(1.0f));
```

## 6. 总结

在电商场景中，`term` 和 `range` 查询的权重设计是优化精准搜索的关键。核心要点包括：

- **权重分配**：`spu_name.keyword`（5.0）> `brand.keyword`（3.0）> `sku_attributes.keyword`（2.0），通过 `boost` 实现。
- **range 查询**：在 `filter` 上下文中过滤价格、库存等，结合 `function_score` 加权业务规则（如高库存）。
- **间隔控制**：结合 `match_phrase` 时，`slop=0` 或 `1` 适合精准匹配。
- **优化策略**：通过 A/B 测试、Explain API 和用户行为数据动态调整权重。
- **分词配合**：`term` 查询使用 `keyword` 类型，`match_phrase` 使用 `ik_smart` 分词器。

通过科学的权重设计，电商搜索系统可以在保证精准查询高相关性的同时，满足用户意图和业务需求，提升搜索体验和转化率