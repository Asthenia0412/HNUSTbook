# SpringCloudGateway与单体项目中跨域问题的解决方案及浏览器限制解析

## 一、引言

在现代Web开发中，跨域问题（Cross-Origin Resource Sharing, CORS）是前后端分离架构中常见的挑战。由于浏览器的同源策略（Same-Origin Policy, SOP），前端应用程序（如运行在`http://frontend.com`的Vue应用）无法直接访问不同源的后端API（如`http://api.backend.com`），这在微服务架构和单体项目中都会遇到。SpringCloudGateway作为微服务架构的统一入口，以及SpringBoot单体项目，都需要妥善配置CORS以确保前端能够顺畅访问后端服务。

一个常见的疑问是：既然浏览器的同源策略限制了跨域请求，导致请求可能无法发送到后端，后端如何通过设置CORS响应头（如`Access-Control-Allow-Origin`）解决跨域问题？这看似矛盾，但实际上，浏览器的跨域限制和后端的CORS机制是协同工作的。本文将详细解答这一问题，结合SpringCloudGateway和Sa-Token的SSO（单点登录）场景，讲解跨域问题的解决方法，并提供单体项目的CORS配置方案。*本文撰写于2025年5月31日，香港时间下午4:20。*

## 二、跨域问题与CORS基础

### 2.1 跨域问题的定义

浏览器的同源策略要求请求的**协议**（如http/https）、**主机名**（如example.com）、**端口号**（如80/443）完全相同，否则视为跨域。例如：

- `http://frontend.com`调用`http://api.backend.com`（主机名不同，跨域）。
- `http://example.com:8080`调用`http://example.com:8081`（端口不同，跨域）。

跨域请求（如AJAX、Fetch）会被浏览器拦截，除非后端通过CORS响应头明确允许。

### 2.2 浏览器的同源策略与跨域限制

浏览器的同源策略（SOP）是Web安全模型的核心，旨在防止恶意网站通过脚本访问其他网站的数据，保护用户隐私和安全。SOP限制了以下行为：

- **JavaScript访问**：一个源的脚本不能直接访问另一个源的DOM或数据（如LocalStorage、Cookie）。
- **XMLHttpRequest/Fetch**：默认情况下，AJAX请求只能发送到同源地址。
- **跨域资源访问**：如iframe、图片、脚本等，部分操作受限。

#### 2.2.1 跨域请求如何发送到后端？

一个关键问题是：如果浏览器限制跨域请求，请求是否能到达后端？答案取决于请求类型：

- 简单请求

  （如GET、POST，满足特定条件，如Content-Type为

  ```
  application/x-www-form-urlencoded
  ```

  ）：

  - 浏览器会发送请求到后端。
  - 后端返回响应，浏览器检查响应头中的`Access-Control-Allow-Origin`是否包含请求的源。
  - 如果不匹配（如缺失或`*`但带凭据），浏览器阻止前端访问响应数据，抛出CORS错误。

- 复杂请求

  （如PUT、DELETE，或自定义头）：

  - 浏览器先发送一个**预检请求**（OPTIONS方法），询问后端是否允许该跨域请求。
  - 后端返回CORS头（如`Access-Control-Allow-Methods`），浏览器根据响应决定是否发送实际请求。
  - 如果预检失败（如后端未返回正确CORS头），实际请求不会发送。

因此，跨域请求通常能到达后端（简单请求直接发送，复杂请求通过预检），但浏览器会根据后端的CORS响应头决定是否允许前端访问响应数据。这解决了“请求出不去浏览器”的误解：请求可以发送到后端，但响应是否可用由CORS头控制。

#### 2.2.2 为什么后端可以解决跨域问题？

后端通过设置CORS响应头，明确告诉浏览器哪些跨域请求是安全的。例如：

- `Access-Control-Allow-Origin: http://frontend.com`表示允许`http://frontend.com`访问。
- `Access-Control-Allow-Credentials: true`支持发送Cookie或认证头（如Sa-Token的Ticket）。
- `Access-Control-Max-Age: 3600`缓存预检结果，减少OPTIONS请求。

浏览器的SOP依赖后端的CORS头来决定放行或拦截响应，从而实现跨域访问的安全控制。

### 2.3 CORS机制

CORS是一种W3C标准，允许服务器声明哪些源可以访问其资源，通过以下HTTP响应头实现：

- `Access-Control-Allow-Origin`：指定允许的源，如`http://frontend.com`或`*`。
- `Access-Control-Allow-Methods`：允许的HTTP方法，如`GET, POST, PUT`。
- `Access-Control-Allow-Headers`：允许的请求头，如`Authorization, Content-Type`。
- `Access-Control-Max-Age`：预检请求的缓存时间。
- `Access-Control-Allow-Credentials`：是否允许发送Cookie等凭据。

## 三、SpringCloudGateway解决跨域问题

SpringCloudGateway作为微服务架构的统一入口，负责请求分发、认证（如Sa-Token的SSO验证）等，跨域配置通常在网关层统一处理，以简化子系统的开发。

### 3.1 SpringCloudGateway的CORS配置方式

SpringCloudGateway提供两种主要方式配置CORS：

1. **全局CORS配置**：通过`application.yml`或Java配置，应用于所有路由。
2. **路由级CORS配置**：针对特定路由设置CORS策略，适合不同子系统有不同跨域需求。

#### 3.1.1 全局CORS配置（application.yml）

在`application.yml`中配置全局CORS规则，适用于所有通过网关的请求：

```yaml
spring:
  cloud:
    gateway:
      globalcors:
        cors-configurations:
          '[/**]': # 匹配所有路径
            allowedOrigins: # 允许的源
              - "http://frontend.com"
              - "http://localhost:3000" # 本地开发
            allowedMethods: # 允许的方法
              - GET
              - POST
              - PUT
              - DELETE
            allowedHeaders: "*" # 允许的请求头
            allowCredentials: true # 允许发送Cookie
            maxAge: 3600 # 预检请求缓存时间（秒）
```

- 说明

  ：

  - `allowedOrigins`：明确指定前端域名，避免使用`*`以提高安全性。
  - `allowCredentials`：设为`true`以支持SSO场景（如Sa-Token的Ticket传递）。
  - `maxAge`：设置3600秒，减少预检请求频率。

#### 3.1.2 路由级CORS配置

若不同子系统（如`crm.example.com`和`erp.example.com`）需要不同CORS策略，可为特定路由配置：

```yaml
spring:
  cloud:
    gateway:
      routes:
        - id: crm_route
          uri: http://crm.example.com
          predicates:
            - Path=/crm/**
          filters:
            - AddResponseHeader=Access-Control-Allow-Origin, http://frontend.com
            - AddResponseHeader=Access-Control-Allow-Methods, GET,POST,PUT
            - AddResponseHeader=Access-Control-Allow-Headers, *
            - AddResponseHeader=Access-Control-Allow-Credentials, true
            - AddResponseHeader=Access-Control-Max-Age, 3600
        - id: erp_route
          uri: http://erp.example.com
          predicates:
            - Path=/erp/**
          filters:
            - AddResponseHeader=Access-Control-Allow-Origin, http://erp.frontend.com
            - AddResponseHeader=Access-Control-Allow-Methods, GET,POST
            - AddResponseHeader=Access-Control-Allow-Headers, Authorization
            - AddResponseHeader=Access-Control-Allow-Credentials, true
```

- **优点**：为不同子系统定制CORS策略，灵活性高。
- **适用场景**：微服务架构中，子系统前端域名不同（如CRM和ERP有独立前端）。

#### 3.1.3 Java代码配置

通过Java配置实现更复杂的CORS逻辑：

```java
@Configuration
public class GatewayCorsConfig {
    @Bean
    public CorsWebFilter corsWebFilter() {
        CorsConfiguration config = new CorsConfiguration();
        config.addAllowedOrigin("http://frontend.com");
        config.addAllowedOrigin("http://localhost:3000");
        config.addAllowedMethod("*");
        config.addAllowedHeader("*");
        config.setAllowCredentials(true);
        config.setMaxAge(3600L);

        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**", config);
        return new CorsWebFilter(source);
    }
}
```

- **适用场景**：需要动态配置CORS（如根据环境变量加载允许的源）。

#### 3.1.4 Sa-Token SSO场景中的CORS

在Sa-Token的SSO模式三（前后端分离）中，前端通过API调用SSO认证中心（如`http://sso.example.com/sso/login`）获取Ticket，网关拦截请求验证Ticket。CORS配置需确保：

- 前端域名（如`http://frontend.com`）在`allowedOrigins`中。
- `allowCredentials: true`以支持Cookie或Ticket传递。
- 网关和SSO认证中心均配置一致的CORS策略，避免请求被拦截。

示例网关过滤器结合Sa-Token验证Ticket：

```java
@Component
public class SaTokenGatewayFilter implements GlobalFilter, Ordered {
    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        // 添加CORS头（也可通过yml配置）
        ServerHttpResponse response = exchange.getResponse();
        response.getHeaders().add("Access-Control-Allow-Origin", "http://frontend.com");
        response.getHeaders().add("Access-Control-Allow-Methods", "GET,POST,PUT,DELETE");
        response.getHeaders().add("Access-Control-Allow-Headers", "*");
        response.getHeaders().add("Access-Control-Allow-Credentials", "true");

        String ticket = exchange.getRequest().getQueryParams().getFirst("ticket");
        if (StringUtils.isEmpty(ticket)) {
            return unauthorizedResponse(exchange, "Missing ticket");
        }
        boolean isValid = SaTokenSSO.checkTicket(ticket);
        if (!isValid) {
            return unauthorizedResponse(exchange, "Invalid ticket");
        }
        return chain.filter(exchange);
    }

    private Mono<Void> unauthorizedResponse(ServerWebExchange exchange, String message) {
        ServerHttpResponse response = exchange.getResponse();
        response.setStatusCode(HttpStatus.UNAUTHORIZED);
        return response.writeString(message);
    }

    @Override
    public int getOrder() {
        return -100;
    }
}
```

### 3.2 微服务架构中的跨域优势

- **统一入口**：网关集中处理CORS，子系统无需单独配置，降低开发复杂性。
- **灵活路由**：路由级CORS配置支持不同子系统的跨域需求。
- **安全性**：网关可结合Sa-Token的`allow-url`限制回调地址，防止Ticket被重定向到恶意站点。
- **高性能**：网关缓存CORS响应头，减少预检请求开销。

## 四、单体项目中的CORS配置

在SpringBoot单体项目中，跨域问题通常由控制器层直接处理，适用于前后端分离但不涉及复杂微服务路由的场景。SpringBoot提供多种CORS配置方式：

### 4.1 全局CORS配置

通过Java配置为所有控制器设置CORS：

```java
@Configuration
public class WebConfig implements WebMvcConfigurer {
    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/**")
                .allowedOrigins("http://frontend.com", "http://localhost:3000")
                .allowedMethods("GET", "POST", "PUT", "DELETE")
                .allowedHeaders("*")
                .allowCredentials(true)
                .maxAge(3600);
    }
}
```

- 说明

  ：

  - `addMapping("/**")`：匹配所有路径。
  - `allowCredentials(true)`：支持SSO场景（如Sa-Token的Cookie传递）。

### 4.2 控制器级CORS配置

使用`@CrossOrigin`注解为特定控制器或方法配置CORS：

```java
@RestController
@RequestMapping("/api")
@CrossOrigin(origins = {"http://frontend.com", "http://localhost:3000"}, 
            methods = {RequestMethod.GET, RequestMethod.POST}, 
            allowCredentials = "true")
public class ApiController {
    @GetMapping("/data")
    public String getData() {
        return "Hello from API";
    }
}
```

- **适用场景**：特定接口需要不同CORS策略。

### 4.3 过滤器级CORS配置

通过自定义过滤器实现灵活的CORS逻辑：

```java
@Component
public class CorsFilter implements Filter {
    @Override
    public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain)
            throws IOException, ServletException {
        HttpServletResponse response = (HttpServletResponse) res;
        response.setHeader("Access-Control-Allow-Origin", "http://frontend.com");
        response.setHeader("Access-Control-Allow-Methods", "GET,POST,PUT,DELETE");
        response.setHeader("Access-Control-Allow-Headers", "*");
        response.setHeader("Access-Control-Allow-Credentials", "true");
        response.setHeader("Access-Control-Max-Age", "3600");
        
        if ("OPTIONS".equalsIgnoreCase(((HttpServletRequest) req).getMethod())) {
            response.setStatus(HttpServletResponse.SC_OK);
            return;
        }
        chain.doFilter(req, res);
    }
}
```

- **优点**：支持动态CORS逻辑（如根据请求头决定允许的源）。

### 4.4 Sa-Token SSO场景中的CORS

在单体项目中使用Sa-Token的SSO模式三，前端通过API调用SSO认证中心（如`/sso/login`），需确保CORS配置支持：

- `allowedOrigins`包含前端域名。
- `allowCredentials`设为`true`，支持Ticket传递。
- 控制器（如`SsoServerController`）添加`@CrossOrigin`或全局CORS配置。

示例SSO控制器：

```java
@RestController
@RequestMapping("/sso")
@CrossOrigin(origins = "http://frontend.com", allowCredentials = "true")
public class SsoServerController {
    @PostMapping("/login")
    public SaResult login(@RequestParam String username, @RequestParam String password) {
        if ("admin".equals(username) && "123456".equals(password)) {
            String userId = "10001";
            StpUtil.login(userId);
            String ticket = SaTokenSSO.createTicket(userId);
            return SaResult.data(new LoginResult(userId, ticket));
        }
        return SaResult.error("用户名或密码错误");
    }
}
```

## 五、解答核心疑问：后端如何解决浏览器跨域限制

### 5.1 为什么请求能到达后端？

一个常见的误解是：浏览器的同源策略阻止跨域请求发送到后端，导致后端无法通过CORS响应头解决问题。实际上：

- **简单请求**：浏览器直接发送请求到后端（如GET/POST）。后端返回响应，包含CORS头（如`Access-Control-Allow-Origin`）。浏览器检查这些头是否允许请求的源，若不匹配，阻止前端访问响应数据，但请求本身已到达后端。
- **复杂请求**：浏览器先发送OPTIONS预检请求，后端返回CORS头（如`Access-Control-Allow-Methods`），浏览器根据响应决定是否发送实际请求。若预检失败，实际请求不会发送，但OPTIONS请求已到达后端。

因此，跨域请求（或预检请求）能够到达后端，后端的CORS头决定响应是否可用。

### 5.2 如何通过后端解决跨域？

后端通过以下方式解决跨域问题：

- **设置CORS头**：通过`Access-Control-Allow-Origin`指定允许的源，确保浏览器放行响应。
- **处理预检请求**：正确响应OPTIONS请求，允许复杂请求继续。
- **支持凭据**：设置`Access-Control-Allow-Credentials: true`，支持Sa-Token SSO中的Ticket或Cookie传递。

在SpringCloudGateway中，网关作为代理，在响应中添加CORS头；在单体项目中，SpringBoot控制器或过滤器直接添加这些头。

## 六、SpringCloudGateway与单体项目的CORS对比

| **特性**     | **SpringCloudGateway**           | **SpringBoot单体项目**               |
| ------------ | -------------------------------- | ------------------------------------ |
| **配置位置** | 网关层，统一处理所有子系统请求   | 控制器层或全局配置                   |
| **适用场景** | 微服务架构，多子系统             | 单体应用或简单前后端分离             |
| **CORS粒度** | 全局或路由级，适合不同子系统定制 | 全局或控制器/方法级                  |
| **SSO集成**  | 网关验证Ticket，统一CORS管理     | 控制器直接处理Ticket，需单独配置CORS |
| **性能**     | 集中处理，减少子系统负担         | 控制器逐个处理，可能增加开销         |
| **复杂度**   | 配置复杂，需考虑路由规则         | 配置简单，适合小型项目               |

## 七、注意事项与最佳实践

1. 安全性

   ：

   - 避免使用`allowedOrigins: "*"`，明确指定前端域名，防止未授权访问。
   - 启用`allowCredentials: true`时，确保`Access-Control-Allow-Origin`为具体域名。
   - 在Sa-Token SSO中，使用`allow-url`限制回调地址，防止Ticket重定向到恶意站点。

2. 性能优化

   ：

   - 设置合理的`maxAge`（如3600秒），减少预检请求。
   - 网关层缓存CORS响应头，降低处理开销。

3. 调试技巧

   ：

   - 使用浏览器开发者工具（Network面板）检查CORS头是否正确返回。
   - 使用`curl`测试OPTIONS请求，验证预检响应。

4. Sa-Token SSO注意事项

   ：

   - 确保SSO认证中心和网关的CORS配置一致。
   - 使用HTTPS，防止Ticket在传输中被拦截。
   - 优先使用HttpOnly Cookie存储Ticket，降低XSS风险。

## 八、总结

SpringCloudGateway通过全局或路由级CORS配置，统一处理微服务架构中的跨域问题，结合Sa-Token的SSO实现，提供安全高效的认证方案。单体项目中，SpringBoot通过全局配置、注解或过滤器实现CORS，适合简单场景。针对“浏览器限制跨域请求如何到达后端”的疑问，浏览器允许请求发送，但通过CORS头控制响应是否可用，后端通过设置适当的CORS头解决跨域问题。本文结合代码示例和Sa-Token SSO场景，提供了全面的跨域解决方案，*撰写于2025年5月31日，香港时间下午4:20*，为开发者提供清晰参考。