# Redis 核心数据结构与 Key 查找流程面试复习

本文通过一个具体的场景——设计一个高并发缓存系统，结合 Redis 的核心数据结构和 Key 查找流程，分析如何解决问题，并提供实战操作和面试深入考察的应对策略。

## 场景：设计一个高并发商品库存缓存系统

假设我们正在开发一个电商平台的商品库存查询系统，用户请求量非常高（每秒数万次查询），需要使用 Redis 作为缓存来存储商品库存数据，以减轻数据库压力。我们需要快速查找商品的库存（Key 为商品 ID，Value 为库存量），并确保系统的高性能和稳定性。

### 1. Redis 核心数据结构

#### A. 为什么需要 Redis 的核心数据结构？

在高并发场景下，Redis 的内存数据库特性使其成为理想的缓存选择。它的核心数据结构（如 redisDb、字典、过期字典）决定了其高效的 Key-Value 存储和查找能力。例如，在我们的商品库存系统中，商品 ID 作为 Key，库存量作为 Value，需要快速存储和检索，同时支持过期机制以确保库存数据的时效性。

**实战问题**：假设商品 ID 为 `product:1001`，我们需要存储其库存量为 500，并设置 1 小时的过期时间。Redis 的核心数据结构如何支持这一需求？

**实战操作**：

1. 存储库存数据：

   ```bash
   SET product:1001 500 EX 3600
   ```

   这条命令将商品 ID `product:1001` 的库存量存储为 500，并设置 1 小时（3600 秒）过期时间。

2. 查看 Redis 内存中的键：

   ```bash
   KEYS product:*
   ```

   确认键是否正确存储。

3. 检查过期时间：

   ```bash
   TTL product:1001
   ```

   返回剩余的 TTL（以秒为单位）。

#### B. Redis 核心数据结构的结构

Redis 的核心数据结构主要包括以下部分：

1. **redisDb 结构体**：
   - 这是 Redis 数据库的抽象表示，每个 Redis 实例可以有多个数据库（默认 16 个，通过 `SELECT <db>` 切换）。
   - 包含以下关键字段：
     - `dict`：全局哈希表，存储所有 Key-Value 对。
     - `expires`：过期字典，存储每个 Key 的过期时间戳。
     - 其他字段如 `id`（数据库编号）、`avg_ttl`（平均过期时间）等。
2. **字典（dict）**：
   - 使用哈希表实现，存储所有 Key-Value 对。
   - 哈希表结构：
     - `dictht`：包含哈希表数组（桶）和大小信息。
     - `dictEntry`：每个桶中的节点，包含 Key、Value（指向 redisObject）和 next 指针（解决哈希冲突的链表）。
   - 链式哈希解决冲突：当多个 Key 哈希值相同，存储在同一桶中，通过链表（next 指针）串联。
3. **过期字典（expires）**：
   - 独立存储 Key 的过期时间戳，结构与 `dict` 类似，但 Value 为时间戳。
   - 用于实现 Key 的自动过期功能。

**结构在场景中的体现**：

- 用户查询 `product:1001` 的库存时，Redis 首先定位到 redisDb 的 `dict`，通过哈希表找到对应的 `dictEntry`，获取库存量（Value）。
- 如果设置了过期时间，Redis 会检查 `expires` 字典，判断 `product:1001` 是否已过期。
- 用户看到的是快速返回的库存量（如 `500`）或空值（如果已过期）。

**日志分析示例**：
假设 Redis 日志显示查询延迟较高，我们可以通过以下命令检查哈希表的状态：

```bash
INFO MEMORY
```

输出示例：

```
used_memory: 1048576
used_memory_human: 1.00M
```

如果内存使用量过高，可能需要检查哈希表负载因子：

```bash
INFO STATS
```

输出示例：

```
dict_load_factor: 0.75
```

负载因子接近 1 时，可能触发扩容，影响性能。

#### C. 面试深入考察应对

**问题 1**：Redis 的哈希表如何处理高并发场景下的扩容？
**回答**：
Redis 使用渐进式 Rehash 机制，避免扩容时的阻塞。扩容触发条件是负载因子（已用槽/总槽）大于 1（或服务器空闲时被动扩容）。渐进式 Rehash 每次操作（如查找、插入）时迁移部分键到新哈希表，直至完成。
**实战补充**：可以通过 `INFO MEMORY` 查看 `used_memory` 和 `dict_load_factor`，判断是否需要优化 Key 设计以减少冲突。

**问题 2**：如果负载因子过高导致性能下降，你会怎么优化？
**回答**：  

1. 优化 Key 设计：使用更分散的 Key 命名（如 `product:category:1001`），降低哈希冲突概率。  
2. 调整 Redis 配置：增大 `hash-max-ziplist-entries`（将小哈希表转为 ziplist 节省内存）或修改 `hz` 参数（控制后台任务频率）。  
3. 分片存储：将数据分散到多个 Redis 实例，使用一致性哈希分配 Key。
   **实战补充**：执行 `CONFIG SET hash-max-ziplist-entries 512` 调整配置，并观察性能变化。

**问题 3**：一致性哈希如何在 Redis 集群中应用？
**回答**：
一致性哈希将 Key 映射到哈希环上的节点，节点增加或移除时只影响部分 Key 的重新分配。Redis Cluster 使用 16384 个槽，Key 通过 CRC16 算法映射到槽，再分配到节点。
**实战补充**：使用 `CLUSTER NODES` 查看槽分配情况，确认 Key 是否均匀分布。

**问题 4**：如果某个节点宕机，Redis 如何保证数据可用性？
**回答**：
Redis Cluster 使用主从复制，每个主节点有若干从节点。宕机后，从节点通过选举（Raft 算法）晋升为主节点。一致性哈希确保槽重新分配后数据仍可访问。
**实战补充**：执行 `CLUSTER INFO` 检查集群状态，确认是否有故障转移。

### 2. Key 的查找流程

#### A. 为什么需要高效的 Key 查找流程？

在高并发库存查询场景中，用户请求 `GET product:1001` 需要亚毫秒级响应。Redis 的 Key 查找流程直接影响响应速度，其哈希表设计和冲突解决机制确保了高效性。

**实战问题**：如何快速查找 `product:1001` 的库存，并分析查找性能？
**实战操作**：

1. 查询库存：

   ```bash
   GET product:1001
   ```

   返回 `500`。

2. 分析查询耗时：

   ```bash
   SLOWLOG GET 10
   ```

   输出示例：

   ```
   1) 1) (integer) 1234  # 慢查询 ID
      2) (integer) 1697051234  # 时间戳
      3) (integer) 150  # 耗时（微秒）
      4) 1) "GET" 2) "product:1001"  # 命令
   ```

   如果耗时过高，可能需要检查哈希冲突或扩容状态。

#### B. Key 查找流程的结构

1. **查找步骤**：
   - 计算 Key 的哈希值：使用 SipHash 算法计算 `product:1001` 的哈希值。
   - 定位哈希桶：通过哈希值对哈希表大小取模，定位到 `dictEntry` 桶。
   - 遍历链表：如果桶中有冲突，通过 `next` 指针遍历链表，找到匹配的 Key。
   - 返回 redisObject：包含 Value（库存量 500）和元数据（如类型、编码）。
2. **性能优化**：
   - **哈希表扩容**：负载因子 > 1 时触发，逐步迁移数据避免阻塞。
   - **缩容**：负载因子 < 0.1 时触发，释放内存。
   - **SipHash 算法**：提供高效且安全的哈希计算，降低冲突概率。
   - **渐进式 Rehash**：每次操作迁移部分键，避免一次性扩容的性能冲击。

**结构在场景中的体现**：

- 用户查询 `product:1001` 时，Redis 计算其哈希值，定位到桶，遍历链表返回库存量。
- 如果哈希表正在 Rehash，用户仍能正常查询，但可能有微小延迟。
- 用户看到的是快速返回的库存值（如 `500`）。

**日志分析示例**：
如果查询性能下降，可以检查慢查询日志：

```bash
SLOWLOG GET 10
```

如果发现大量慢查询，可能需要优化 Key 分布或检查 Rehash 状态：

```bash
INFO COMMANDSTATS
```

输出示例：

```
cmdstat_get: calls=10000, usec=15000, usec_per_call=1.50
```

分析 `usec_per_call` 是否合理。

#### C. 面试深入考察应对

**问题 1**：Redis 的 Key 查找如何处理哈希冲突？
**回答**：
Redis 使用链式哈希解决冲突，相同哈希值的 Key 存储在同一桶的链表中，通过 `next` 指针遍历查找。SipHash 算法尽量减少冲突概率。
**实战补充**：执行 `INFO STATS` 查看 `dict_load_factor`，如果过高，优化 Key 命名。

**问题 2**：如果哈希表正在 Rehash，查找性能会受影响吗？
**回答**：
渐进式 Rehash 每次操作迁移少量键，影响较小。但在高并发场景下，Rehash 可能导致微秒级延迟。可以通过 `INFO MEMORY` 监控 `used_memory` 和 Rehash 状态，必要时暂停后台任务（调整 `hz` 参数）。
**实战补充**：执行 `CONFIG SET hz 10` 降低 Rehash 频率，观察性能变化。

**问题 3**：如何优化 Key 查找性能？
**回答**：  

1. 优化 Key 命名：使用分层命名（如 `product:electronics:1001`）分散哈希值。  

2. 调整哈希表参数：增大 `hash-max-ziplist-entries` 减少小哈希表的内存占用。  

3. 使用 Pipeline 或 Lua 脚本：批量操作减少网络开销。

   实战补充

   ：执行以下 Lua 脚本批量查询库存：

   ```lua
   local keys = {"product:1001", "product:1002"}
   local result = {}
   for i, key in ipairs(keys) do
       result[i] = redis.call("GET", key)
   end
   return result
   ```

   保存为 

   ```
   batch_get.lua
   ```

   ，运行：

   ```bash
   EVAL "$(cat batch_get.lua)" 0
   ```

**问题 4**：如果 Redis 集群中某个节点的哈希槽迁移，查找会失败吗？
**回答**：
Redis Cluster 使用一致性哈希，Key 映射到 16384 个槽。槽迁移期间，客户端收到 `MOVED` 或 `ASK` 重定向响应，自动重试到正确节点。
**实战补充**：执行 `CLUSTER SLOTS` 查看槽分布，确认迁移状态。

## 总结

通过分析 Redis 在高并发商品库存缓存场景中的应用，我们理解了其核心数据结构（redisDb、字典、过期字典）和 Key 查找流程（哈希计算、桶定位、链表遍历）。实战操作展示了如何存储、查询和优化性能，而面试应对策略则覆盖了从基本原理到深入优化的多层问题。通过这些知识，我们可以自信应对 Redis 相关的面试考察，同时在实际项目中高效应用 Redis。