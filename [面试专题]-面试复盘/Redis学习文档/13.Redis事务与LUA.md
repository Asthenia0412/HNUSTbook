# Redis 事务与 Lua 脚本面试复习

本文通过一个电商库存扣减的场景，讲解 Redis 事务和 Lua 脚本的核心机制、结构、实战操作，以及面试中可能遇到的深入考察问题。我们将从零开始介绍 Lua 脚本，结合具体问题解决，确保内容既有实战性又覆盖八股文知识点。

## 场景：实现高并发库存扣减系统

假设我们正在开发一个电商平台的库存扣减系统，用户下单时需要检查并扣减商品库存（Key 为 `inventory:product:1001`，Value 为库存量）。系统需满足以下要求：

1. 扣减操作必须原子性，避免超卖。
2. 高并发下性能要高，尽量减少网络开销。
3. 支持错误处理，如库存不足时返回明确提示。

我们将分别使用 Redis 事务和 Lua 脚本解决这个问题，分析它们的优劣，并展示底层实现。

------

## 1. Redis 事务

### A. 为什么需要 Redis 事务？

在库存扣减场景中，事务可以确保检查库存和扣减库存的操作要么全部执行，要么全部不执行，避免并发导致的数据不一致。例如，两个用户同时下单，事务可以防止超卖。

**实战问题**：如何使用事务实现 `inventory:product:1001` 的库存扣减？
**实战操作**：

1. 使用 `WATCH` 监控库存 Key，确保在事务执行前库存未被修改：

   ```bash
   WATCH inventory:product:1001
   ```

2. 开启事务，检查并扣减库存：

   ```bash
   MULTI
   GET inventory:product:1001
   DECR inventory:product:1001
   EXEC
   ```

   如果 `WATCH` 检测到 Key 被修改，`EXEC` 返回 `nil`，表示事务失败。

3. 检查事务结果：

   ```bash
   redis> WATCH inventory:product:1001
   OK
   redis> MULTI
   OK
   redis> GET inventory:product:1001
   QUEUED
   redis> DECR inventory:product:1001
   QUEUED
   redis> EXEC
   1) "100"  # 当前库存
   2) (integer) 99  # 扣减后库存
   ```

**问题分析**：如果库存为 0，事务不会阻止 `DECR` 执行（可能导致负库存），需要额外逻辑判断。

### B. Redis 事务的结构

1. **事务核心组件**：
   - **multiState**：存储事务队列，包含命令和参数（`commands` 数组）。
   - **watched_keys**：存储 `WATCH` 监控的 Key 和版本号（CAS机制）。
   - **redisDb**：事务操作的数据库上下文，包含全局哈希表（`dict`）。
2. **执行流程**：
   - `MULTI`：初始化事务队列，标记客户端进入事务状态。
   - 命令入队：每个命令（如 `GET`、`DECR`）存储为 `QUEUED` 状态。
   - `EXEC`：顺序执行队列中命令，若 `WATCH` 的 Key 被修改，事务失败。
   - `DISCARD`：清空队列，退出事务状态。

**结构在场景中的体现**：

- 用户下单时，客户端发送 `WATCH inventory:product:1001` 和 `MULTI`，Redis 将命令存储在 `multiState` 中。
- `EXEC` 执行时，检查 `watched_keys` 中 Key 的版本号，若未变化则扣减库存，返回新库存值。
- 用户看到的是扣减结果（如 `99`）或失败提示（`nil`）。

**日志分析示例**：
如果事务失败频繁，检查慢查询日志：

```bash
SLOWLOG GET 10
```

输出示例：

```
1) 1) (integer) 1234
   2) (integer) 1697051234
   3) (integer) 200
   4) 1) "EXEC"
```

高耗时可能由于 `WATCH` 冲突，需优化并发逻辑。

### C. 面试深入考察应对

**问题 1**：Redis 事务为何不提供回滚机制？
**回答**：
Redis 事务基于单线程模型，保证命令顺序执行，但不提供回滚以简化设计和提高性能。运行时错误（如对字符串执行 `INCR`）仅影响当前命令，其他命令继续执行。
**实战补充**：在库存扣减中，需在事务前用 `GET` 检查库存是否大于 0，避免负库存。

**问题 2**：WATCH 的 CAS 机制如何实现？
**回答**：
`WATCH` 将 Key 记录在 `watched_keys` 字典中，关联客户端和 Key 的版本号。每次 Key 修改（如 `SET`、`DECR`）会更新版本号。`EXEC` 时检查版本号，若变化则事务失败。
**实战补充**：执行 `INFO STATS` 查看 `rejected_commands` 统计，判断 `WATCH` 冲突频率。

**问题 3**：如何优化事务在高并发场景下的性能？
**回答**：  

1. 减少事务长度：避免长事务，尽量合并命令。  

2. 使用 Pipeline：批量发送命令，减少网络往返。  

3. 替换事务：对于复杂逻辑，使用 Lua 脚本替代事务。

   实战补充

   ：使用 Pipeline 执行：

   ```bash
   redis-cli --pipe < commands.txt
   ```

   其中 

   ```
   commands.txt
   ```

    包含 

   ```
   MULTI
   ```

   、

   ```
   GET
   ```

   、

   ```
   DECR
   ```

   、

   ```
   EXEC
   ```

   。

**问题 4**：事务在 Redis 集群中的局限性是什么？
**回答**：
事务要求所有 Key 在同一节点（同一哈希槽）。若 Key 分布在不同节点，事务失败。可以使用 `{tag}`（如 `inventory:{product}:1001`）强制路由到同一槽。
**实战补充**：执行 `CLUSTER KEYSLOT inventory:product:1001` 确认槽位置。

------

## 2. Lua 脚本（从零开始讲解）

### A. 为什么需要 Lua 脚本？

在库存扣减场景中，事务无法实现复杂逻辑（如检查库存 > 0 后再扣减）。Lua 脚本支持原子性执行复杂逻辑，减少网络开销，适合高并发场景。

**从零开始讲解 Lua 脚本**：

- **什么是 Lua 脚本**？
  Lua 是一种轻量级脚本语言，Redis 内置 Lua 5.1 解释器，允许在服务器端执行脚本。脚本通过 `EVAL` 命令运行，整体原子性执行，期间其他命令无法插队。

- 基本用法

  ：

  使用 

  ```
  EVAL
  ```

   命令运行脚本，格式为：

  ```bash
  EVAL "script" numkeys key1 key2 ... arg1 arg2 ...
  ```

  - `script`：Lua 代码字符串。
  - `numkeys`：访问的 Key 数量。
  - `key1 key2 ...`：通过 `KEYS[]` 访问的 Key。
  - `arg1 arg2 ...`：通过 `ARGV[]` 传递的参数。

**实战问题**：如何用 Lua 脚本实现原子化库存扣减？
**实战操作**：

1. 编写 Lua 脚本（检查库存并扣减）：

   ```lua
   local stock = tonumber(redis.call('GET', KEYS[1]))
   if stock > 0 then
       redis.call('DECR', KEYS[1])
       return 1
   else
       return 0
   end
   ```

2. 保存为 `deduct_stock.lua`，执行：

   ```bash
   EVAL "$(cat deduct_stock.lua)" 1 inventory:product:1001
   ```

   返回 `1`（扣减成功）或 `0`（库存不足）。

3. 优化：使用 `SCRIPT LOAD` 和 `EVALSHA` 缓存脚本：

   ```bash
   redis> SCRIPT LOAD "$(cat deduct_stock.lua)"
   "a1b2c3d4e5f6..."  # 返回 SHA1 哈希
   redis> EVALSHA a1b2c3d4e5f6... 1 inventory:product:1001
   (integer) 1
   ```

### B. Lua 脚本的结构

1. **核心组件**：

   - **Lua 解释器**：Redis 内置修改版 Lua 5.1，运行在沙盒环境中，禁用文件操作等危险函数。

   - **lua_scripts 字典**：存储脚本的 SHA1 哈希和内容（通过 `SCRIPT LOAD` 缓存）。

   - KEYS 和 ARGV

     ：

     - `KEYS[]`：显式声明访问的 Key，用于集群路由。
     - `ARGV[]`：传递额外参数，如扣减量或超时时间。

   - **返回值**：Lua 的 `return` 值转换为 Redis 协议返回（如整数、字符串、数组）。

2. **执行流程**：

   - `EVAL`：将脚本和参数发送到 Redis，解析并执行。
   - `SCRIPT LOAD`：缓存脚本，返回 SHA1 哈希。
   - `EVALSHA`：使用 SHA1 执行缓存脚本，减少传输开销。
   - `SCRIPT FLUSH`：清空脚本缓存。

**结构在场景中的体现**：

- 用户下单时，客户端发送 Lua 脚本，Redis 在单线程中执行，检查并扣减 `inventory:product:1001`。
- 脚本返回 `1`（成功）或 `0`（失败），用户看到明确的扣减结果。
- 缓存的脚本通过 `EVALSHA` 快速复用，降低网络开销。

**日志分析示例**：
检查 Lua 脚本性能：

```bash
INFO COMMANDSTATS
```

输出示例：

```
cmdstat_eval: calls=1000, usec=5000, usec_per_call=5.00
```

若 `usec_per_call` 过高，可能需要优化脚本逻辑（如避免循环）。

### C. 面试深入考察应对

**问题 1**：Lua 脚本如何保证原子性？
**回答**：
Redis 的单线程模型确保 Lua 脚本执行期间不被其他命令打断。脚本作为一个整体运行，中间结果不可见。
**实战补充**：使用 `SCRIPT KILL` 终止长时间运行的脚本：

```bash
SCRIPT KILL
```

**问题 2**：Lua 脚本的沙盒机制如何实现安全性？
**回答**：
Redis 的 Lua 解释器禁用危险函数（如 `io.*`、`os.*`），限制脚本只能通过 `redis.call` 或 `redis.pcall` 访问 Redis 数据。全局变量受限，防止内存泄漏。
**实战补充**：避免在脚本中使用全局变量：

```lua
local value = redis.call('GET', KEYS[1])  -- 正确
global_value = redis.call('GET', KEYS[1])  -- 错误，可能导致内存泄漏
```

**问题 3**：如何在 Redis 集群中使用 Lua 脚本？
**回答**：
Lua 脚本要求所有 `KEYS[]` 在同一节点（同一哈希槽）。使用 `{tag}`（如 `inventory:{product}:1001`）强制路由。
**实战补充**：检查槽分布：

```bash
CLUSTER KEYSLOT inventory:{product}:1001
```

**问题 4**：如何优化 Lua 脚本的性能？
**回答**：  

1. 使用 `SCRIPT LOAD` 和 `EVALSHA` 缓存脚本，减少传输开销。  

2. 避免复杂逻辑：如循环遍历大量 Key，改用 Redis 数据结构（如 Hash）。  

3. 使用 

   ```
   redis.pcall
   ```

    处理潜在错误，防止脚本中断。

   实战补充

   ：改写脚本使用 

   ```
   redis.pcall
   ```

   ：

   ```lua
   local stock = redis.pcall('GET', KEYS[1])
   if stock == nil then return -1 end
   stock = tonumber(stock)
   if stock > 0 then
       redis.call('DECR', KEYS[1])
       return 1
   else
       return 0
   end
   ```

------

## 3. 事务 vs Lua 脚本：场景选择

| **特性**     | **事务**           | **Lua 脚本**                   |
| ------------ | ------------------ | ------------------------------ |
| **原子性**   | 批量执行命令       | 脚本整体执行                   |
| **错误处理** | 部分失败（无回滚） | 语法错误拒绝执行，运行时可处理 |
| **性能**     | 逐条解析命令       | 预编译+缓存                    |
| **灵活性**   | 仅支持简单命令组合 | 支持复杂逻辑（循环、条件）     |
| **集群支持** | 需 Key 在同一节点  | 可通过 hash tag 路由           |

**场景选择**：

- **事务**：适合简单批量操作，如批量设置多个 Key。
- **Lua 脚本**：适合复杂逻辑，如库存扣减（需判断库存）或分布式锁。

**实战示例**（分布式锁）：

```lua
-- lock.lua
if redis.call('SET', KEYS[1], ARGV[1], 'PX', ARGV[2], 'NX') then
    return 1  -- 锁获取成功
else
    return 0  -- 锁已被占用
end
```

执行：

```bash
EVAL "$(cat lock.lua)" 1 lock:product:1001 client123 10000
```

------

## 4. 调试与问题排查

**慢查询分析**：

```bash
SLOWLOG GET 10
```

检查事务或脚本的执行时间。

**脚本缓存检查**：

```bash
SCRIPT EXISTS a1b2c3d4e5f6...
```

确认脚本是否已缓存。

**集群问题排查**：

```bash
CLUSTER NODES
```

检查节点状态，确保 Key 路由正确。

------

## 5. 最佳实践

1. 事务

   ：

   - 尽量缩短事务长度，避免阻塞。
   - 使用 `WATCH` 实现乐观锁，处理并发冲突。

2. Lua 脚本

   ：

   - 显式声明 `KEYS[]`，支持集群路由。
   - 使用 `SCRIPT LOAD` 和 `EVALSHA` 优化性能。
   - 避免复杂循环或全局变量。

3. 避免问题

   ：

   - 不要在 Lua 中使用 `KEYS *`（可能导致不一致）。
   - 检查脚本返回值，处理异常情况。

------

## 总结

通过电商库存扣减场景，我们分析了 Redis 事务和 Lua 脚本的应用。事务适合简单批量操作，Lua 脚本则支持复杂逻辑和高性能需求。实战操作展示了如何实现原子化扣减，日志分析帮助排查性能问题，面试应对策略覆盖了从基本原理到优化方案的多层考察。掌握这些知识，可以自信应对 Redis 事务和 Lua 脚本相关的面试问题，并在实际项目中高效应用。